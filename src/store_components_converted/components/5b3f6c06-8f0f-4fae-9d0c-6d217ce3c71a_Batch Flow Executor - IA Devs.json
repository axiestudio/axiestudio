{
  "id": "5b3f6c06-8f0f-4fae-9d0c-6d217ce3c71a",
  "name": "Batch Flow Executor - IA Devs",
  "description": "Execute a specific Langflow by name with a list of input messages, email address, and CPF. (Converted from Langflow Store for AxieStudio compatibility)",
  "type": "COMPONENT",
  "is_component": true,
  "author": {
    "username": "NamastexLabs",
    "first_name": "Felipe",
    "last_name": "Rosa",
    "id": "37095b75-b1f7-4e35-aea6-bcc9bbf1e2c7",
    "full_name": "Felipe Rosa"
  },
  "store_url": "https://www.langflow.store/store/component/5b3f6c06-8f0f-4fae-9d0c-6d217ce3c71a",
  "stats": {
    "downloads": 0,
    "likes": 0
  },
  "dates": {
    "created": "2024-08-18T20:00:27.446Z",
    "updated": "2024-08-21T20:47:43.695Z",
    "downloaded": "2025-08-19T17:50:06.771Z"
  },
  "tags": [],
  "technical": {
    "last_tested_version": "1.0.15",
    "private": false,
    "status": "Public"
  },
  "data": {
    "edges": [],
    "nodes": [
      {
        "data": {
          "type": "BatchFlowExecutorComponent",
          "node": {
            "template": {
              "_type": "Component",
              "input_data_list": {
                "trace_as_metadata": true,
                "list": true,
                "trace_as_input": true,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "input_data_list",
                "value": "",
                "display_name": "Input Data List",
                "advanced": false,
                "input_types": [
                  "Data"
                ],
                "dynamic": false,
                "info": "A list of Data objects, each containing 'question' and 'ground_truth' keys to be passed to the flow.",
                "title_case": false,
                "type": "other",
                "_input_type": "DataInput"
              },
              "code": {
                "type": "code",
                "required": true,
                "placeholder": "",
                "list": false,
                "show": true,
                "multiline": true,
                "value": "import re\r\nimport json\r\nfrom typing import List, Any, Dict, Union, Optional\r\nfrom axiestudio.custom import Component\r\nfrom axiestudio.io import DataInput, Output, MessageInput, DropdownInput\r\nfrom axiestudio.schema import Data\r\nfrom loguru import logger\r\nimport langwatch\r\nimport aiohttp\r\nimport asyncio\r\nimport time\r\n\r\nclass BatchFlowExecutorComponent(Component):\r\n    display_name = \"Batch Flow Executor - IA Devs\"\r\n    description = \"Execute a specific Langflow by name with a list of input messages, email address, and CPF.\"\r\n    icon = \"list-restart\"\r\n    \r\n    LANGWATCH_API_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0aW1lc3RhbXAiOjE3MjI2Mjc0NjM1MTMsInJhbmQiOjAuNjE5NzU0NDkyMjY5NzM0LCJpYXQiOjE3MjI2Mjc0NjN9._7Qb9ezb1Lk9KB8DNkwWivHestRwdkqxC15VgWxTXTg\"\r\n        \r\n    def get_flow_names(self) -> List[str]:\r\n        flow_data = self.list_flows()\r\n        return [flow_data.data[\"name\"] for flow_data in flow_data]\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"input_data_list\",\r\n            display_name=\"Input Data List\",\r\n            info=\"A list of Data objects, each containing 'question' and 'ground_truth' keys to be passed to the flow.\",\r\n            is_list=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"flow_name\",\r\n            display_name=\"Flow Name\",\r\n            info=\"The name of the flow to run.\",\r\n            options=[],\r\n            refresh_button=True,\r\n        ),\r\n        MessageInput(\r\n            name=\"email_address\",\r\n            display_name=\"Email Address\",\r\n            info=\"Email address for notifications or identification.\",\r\n        ),\r\n        MessageInput(\r\n            name=\"cpf\",\r\n            display_name=\"CPF\",\r\n            info=\"CPF for identification.\",\r\n        ),\r\n        MessageInput(\r\n            name=\"user_name\",\r\n            display_name=\"User Name\",\r\n            info=\"Full name of the user.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Output Data List\", name=\"output_data_list\", method=\"execute_flow_batch\"),\r\n    ]\r\n\r\n    def validate_email(self, email):\r\n        pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\r\n        return re.match(pattern, email) is not None\r\n\r\n    def validate_cpf(self, cpf):\r\n        if not re.match(r'^(?!(\\d)\\1{10})\\d{9}[\\d]{2}$', cpf):\r\n            return False\r\n        total = sum(int(cpf[i]) * (10 - i) for i in range(9))\r\n        check1 = (total * 10 % 11) % 10\r\n        total = sum(int(cpf[i]) * (11 - i) for i in range(10))\r\n        check2 = (total * 10 % 11) % 10\r\n        return cpf[-2:] == f\"{check1}{check2}\"\r\n\r\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None):\r\n        if field_name == \"flow_name\":\r\n            build_config[\"flow_name\"][\"options\"] = self.get_flow_names()\r\n        return build_config\r\n\r\n    @staticmethod\r\n    def extract_component_output(run_output: List[Any], component_name: str) -> Union[Dict[str, Any], None]:\r\n        if not run_output or not isinstance(run_output[0], object) or not hasattr(run_output[0], 'outputs'):\r\n            logger.error(f\"Invalid run_output structure: {run_output}\")\r\n            return None\r\n        \r\n        for output in run_output[0].outputs:\r\n            if hasattr(output, 'component_display_name') and component_name in output.component_display_name:\r\n                if 'Langwatch Evaluator' in output.component_display_name:\r\n                    trace_data = output.outputs.get('trace_url', {})\r\n                    logger.debug(\"Langwatch Evaluator DATA: \")\r\n                    logger.debug(trace_data)\r\n                    \r\n                    if isinstance(trace_data, dict):\r\n                        message = trace_data.get('message', {})\r\n                        if isinstance(message, dict):\r\n                            return {\r\n                                'trace_url': message.get('trace_url', ''),\r\n                                'flow_trace_id': message.get('flow_trace_id', ''),\r\n                                'eval_trace_id': message.get('eval_trace_id', '')\r\n                            }\r\n                        else:\r\n                            return {\r\n                                'trace_url': str(message),\r\n                                'flow_trace_id': '',\r\n                                'eval_trace_id': ''\r\n                            }\r\n                    elif isinstance(trace_data, str):\r\n                        try:\r\n                            trace_dict = json.loads(trace_data)\r\n                            message = trace_dict.get('message', {})\r\n                            return {\r\n                                'trace_url': message.get('trace_url', ''),\r\n                                'flow_trace_id': message.get('flow_trace_id', ''),\r\n                                'eval_trace_id': message.get('eval_trace_id', '')\r\n                            }\r\n                        except json.JSONDecodeError:\r\n                            logger.warning(f\"Failed to parse trace_url JSON: {trace_data}\")\r\n                            return {'trace_url': trace_data, 'flow_trace_id': '', 'eval_trace_id': ''}\r\n                    else:\r\n                        logger.warning(f\"Unexpected trace_url type: {type(trace_data)}\")\r\n                        return {'trace_url': str(trace_data), 'flow_trace_id': '', 'eval_trace_id': ''}\r\n                \r\n                elif 'Chat Output' in output.component_display_name:\r\n                    message = output.results.get('message', {})\r\n                    if isinstance(message, dict):\r\n                        return {\r\n                            'text': message.get('text', '')\r\n                        }\r\n                    elif hasattr(message, 'text'):\r\n                        return {\r\n                            'text': message.text\r\n                        }\r\n                    else:\r\n                        return {\r\n                            'text': str(message)\r\n                        }\r\n                        \r\n        logger.warning(f\"No matching output found for component: {component_name}\")\r\n        return None\r\n    \r\n    \r\n    async def fetch_evaluation(self, eval_trace_id: str) -> Dict[str, Any]:\r\n        url = f\"https://app.langwatch.ai/api/trace/{eval_trace_id}\"\r\n        headers = {\"X-Auth-Token\": self.LANGWATCH_API_KEY}\r\n        async with aiohttp.ClientSession() as session:\r\n            try:\r\n                async with session.get(url, headers=headers) as response:\r\n                    if response.status == 200:\r\n                        data = await response.json()\r\n                        evaluations = data.get('evaluations', [])\r\n                        if evaluations:\r\n                            evaluation = evaluations[0]\r\n                            return {\r\n                                \"passed\": evaluation.get('passed', False),\r\n                                \"details\": evaluation.get('details', \"Not able to fetch evaluation, check trace URL to see the result.\")\r\n                            }\r\n                        else:\r\n                            logger.warning(f\"No evaluations found for trace {eval_trace_id}\")\r\n                            return {\"passed\": False, \"details\": \"No evaluations found\"}\r\n                    else:\r\n                        logger.error(f\"Failed to retrieve trace info. Status: {response.status}\")\r\n                        return {\"passed\": False, \"details\": f\"API request failed with status {response.status}\"}\r\n            except aiohttp.ClientError as e:\r\n                logger.error(f\"Error occurred while retrieving trace info: {str(e)}\")\r\n                return {\"passed\": False, \"details\": f\"API request error: {str(e)}\"}\r\n    \r\n    async def fetch_metrics(self, flow_trace_id: str) -> Dict[str, Any]:\r\n        url = f\"https://app.langwatch.ai/api/trace/{flow_trace_id}\"\r\n        headers = {\"X-Auth-Token\": self.LANGWATCH_API_KEY}\r\n        async with aiohttp.ClientSession() as session:\r\n            try:\r\n                async with session.get(url, headers=headers) as response:\r\n                    if response.status == 200:\r\n                        data = await response.json()\r\n                        metrics = data.get('metrics', {})\r\n                        return {\r\n                            \"first_token_ms\": metrics.get('first_token_ms'),\r\n                            \"total_time_ms\": metrics.get('total_time_ms'),\r\n                            \"prompt_tokens\": metrics.get('prompt_tokens'),\r\n                            \"completion_tokens\": metrics.get('completion_tokens'),\r\n                            \"tokens_estimated\": metrics.get('tokens_estimated', False)\r\n                        }\r\n                    else:\r\n                        logger.error(f\"Failed to retrieve metrics. Status: {response.status}\")\r\n                        return {}\r\n            except aiohttp.ClientError as e:\r\n                logger.error(f\"Error occurred while retrieving metrics: {str(e)}\")\r\n                return {}\r\n\r\n    def get_flow(self, flow_name: str) -> Optional[Data]:\r\n        flow_datas = self.list_flows()\r\n        for flow_data in flow_datas:\r\n            if flow_data.data[\"name\"] == flow_name:\r\n                return flow_data\r\n        return None\r\n\r\n    def get_component_id_by_name(self, flow_name: str, component_name: str) -> str:\r\n        flow = self.get_flow(flow_name)\r\n        for node in flow.data.get(\"nodes\", []):\r\n            display_name = node.get(\"data\", {}).get(\"node\", {}).get(\"display_name\", \"\")\r\n            if display_name.startswith(component_name) or component_name in display_name:\r\n                return node.get(\"id\", \"\")\r\n        logger.warning(f\"Component starting with or containing '{component_name}' not found in flow '{flow_name}'\")\r\n        return \"\"\r\n\r\n    async def execute_flow_batch(self) -> List[Data]:\r\n        logger.info(\"Starting execute_flow_batch method\")\r\n        \r\n        langwatch.api_key = self.LANGWATCH_API_KEY\r\n\r\n        try:\r\n            email = self.email_address.text\r\n            cpf = self.cpf.text\r\n            user_name = self.user_name.text\r\n\r\n            if not self.validate_email(email):\r\n                raise ValueError(f\"Invalid email address: {email}\")\r\n            if not self.validate_cpf(cpf):\r\n                raise ValueError(f\"Invalid CPF: {cpf}\")\r\n            \r\n            flow_name = self._attributes.get(\"flow_name\")\r\n            \r\n            langwatch_evaluator_id = self.get_component_id_by_name(flow_name, \"Langwatch Evaluator\")\r\n            logger.debug(\"LANGWATCH EVALUATOR ID: \" + langwatch_evaluator_id)        \r\n            input_data_list = self.input_data_list\r\n            output_data_list = []\r\n            pending_evaluations = []\r\n\r\n            for index, input_data in enumerate(input_data_list, start=1):\r\n                logger.info(f\"Processing input data {index}/{len(input_data_list)}\")\r\n                if not isinstance(input_data, Data) or 'question' not in input_data.data:\r\n                    logger.warning(f\"Skipping invalid input data: {input_data}\")\r\n                    continue\r\n                \r\n                input_text = input_data.data['question']\r\n                question_id = input_data.data['id']\r\n                result = await self.run_flow(\r\n                    inputs={\"input_value\": input_text},\r\n                    flow_name=flow_name,\r\n                    tweaks={\r\n                        \"Langwatch Evaluator - Agent API\": {\r\n                            \"question_id\": question_id,\r\n                            \"user_email\": email,\r\n                            \"user_cpf\": cpf,\r\n                            \"user_name\": user_name\r\n                        },\r\n                    },\r\n                    output_type=\"debug\"\r\n                )\r\n                \r\n                logger.debug(f\"Run flow result: {result}\")\r\n                \r\n                chat_output = self.extract_component_output(result, \"Chat Output\")\r\n                langwatch_output = self.extract_component_output(result, \"Langwatch Evaluator\")\r\n                \r\n                response = chat_output['text'] if chat_output else \"Response not found\"\r\n                trace_url = langwatch_output.get('trace_url', \"Trace URL not found\") if langwatch_output else \"Trace URL not found\"\r\n                flow_trace_id = langwatch_output.get('flow_trace_id', \"\") if langwatch_output else \"\"\r\n                eval_trace_id = langwatch_output.get('eval_trace_id', \"\") if langwatch_output else \"\"\r\n                \r\n                output_data = Data(data={\r\n                    \"id\": question_id,\r\n                    \"question\": input_text,\r\n                    \"flow_response\": response,\r\n                    \"langwatch_trace_url\": trace_url,\r\n                    \"langwatch_flow_trace_id\": flow_trace_id,\r\n                    \"langwatch_eval_trace_id\": eval_trace_id,\r\n                })\r\n                output_data_list.append(output_data)\r\n                pending_evaluations.append((output_data, flow_trace_id, eval_trace_id))\r\n                logger.info(f\"Added output data for input {index}\")\r\n\r\n            logger.info(f\"Finished processing all inputs. Total outputs: {len(output_data_list)}\")\r\n            \r\n            # Wait for 15 seconds before fetching evaluations and metrics\r\n            logger.info(\"Waiting 15 seconds before fetching evaluations and metrics...\")\r\n            await asyncio.sleep(15)\r\n            \r\n            # Fetch evaluations and metrics for all flows\r\n            for output_data, flow_trace_id, eval_trace_id in pending_evaluations:\r\n                evaluation_results = await self.fetch_evaluation(eval_trace_id)\r\n                metrics_result = await self.fetch_metrics(flow_trace_id)\r\n                \r\n                logger.debug(f\"Evaluation results: {evaluation_results}\")\r\n                logger.debug(f\"Metrics result: {metrics_result}\")\r\n                \r\n                output_data.data.update({\r\n                    \"evaluation_passed\": evaluation_results[\"passed\"],\r\n                    \"evaluation_details\": evaluation_results[\"details\"],\r\n                    \"total_run_time_ms\": metrics_result.get(\"total_time_ms\"),\r\n                    \"prompt_tokens\": metrics_result.get(\"prompt_tokens\"),\r\n                    \"completion_tokens\": metrics_result.get(\"completion_tokens\"),\r\n                })\r\n\r\n            self.status = output_data_list\r\n            return output_data_list\r\n        \r\n        except ValueError as ve:\r\n            logger.error(f\"Validation error: {str(ve)}\")\r\n            self.status = str(ve)\r\n            raise ve\r\n            \r\n        except Exception as e:\r\n            error_message = f\"Error executing flow batch: {str(e)}\"\r\n            logger.error(error_message)\r\n            logger.exception(\"Full exception traceback:\")\r\n            self.status = error_message\r\n            return [Data(data={\"error\": error_message})]\r\n            \r\n        finally:\r\n            logger.info(\"Finished execute_flow_batch method\")",
                "fileTypes": [],
                "file_path": "",
                "password": false,
                "name": "code",
                "advanced": true,
                "dynamic": true,
                "info": "",
                "load_from_db": false,
                "title_case": false
              },
              "cpf": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "cpf",
                "value": "43091004813",
                "display_name": "CPF",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "CPF for identification.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageInput"
              },
              "email_address": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "email_address",
                "value": "salvatoregames@gmail.com",
                "display_name": "Email Address",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Email address for notifications or identification.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageInput"
              },
              "flow_name": {
                "trace_as_metadata": true,
                "options": [
                  "Competição Langflow Agent",
                  "CSV LLM Iterator (1)",
                  "url scraping (1)",
                  "Untitled document (6)",
                  "Topic Breaker",
                  "Untitled document (1)",
                  "Untitled document (2)",
                  "Memory Chatbot",
                  "Untitled document (3)",
                  "Untitled document (4)",
                  "Untitled document (5)",
                  "PDF Scraper",
                  "Langflow Component Helper",
                  "Prompt Chaining",
                  "Prompt Maker",
                  "Memory Chatbot (1)",
                  "prod - eval - semana 01",
                  "Memory Chatbot (2)",
                  "classify",
                  "Untitled document",
                  "desafio_semana_2_metodo_prompt_dinamico",
                  "EVAL COMPETICAO RAG",
                  "Chat FAQ",
                  "IA Devs - Desafio 1 - Dayvison Pellegrina",
                  "IA Devs - Desafio 1 - Chain v2 - Matheus S.",
                  "Untitled document (8)",
                  "IA Devs - Desafio 1 - Chain v2 - Matheus S. (1)",
                  "desafio_semana_2_metodo_prompt_dinamico (1)",
                  "desafio_semana_2_metodo_rag",
                  "Untitled document (9)",
                  "Sequential Tasks Agent",
                  "desafio_semana_2_metodo_rag  com ASTRA",
                  "Vector Store RAG",
                  "Experimento RAG - reranking e interador",
                  "Sequential Tasks Agent (1)",
                  "Hierarchical Tasks Agent",
                  "Untitled document (10)",
                  "IA Devs - Desafio 1 - Chain v2 - Matheus S. (2)",
                  "IA Devs - Desafio 1 - Chain v2 - Matheus S. (3)",
                  "Untitled document (11)",
                  "Vector Store RAG (1)",
                  "Basic Prompting (Hello, World)",
                  "Sequential Tasks Agent (2)",
                  "Document QA",
                  "Flow Avaliação Semana 2 - RAG ",
                  "testonho-semana2",
                  "Untitled document (7)",
                  "Untitled document (12)",
                  "24bd6b8a-0378-46ae-a95c-7cc85b024828 SW V2",
                  "Untitled document (1) (1)",
                  "Langflow Buddy",
                  "Memory Chatbot (3)",
                  "Hierarchical Tasks Agent (1)",
                  "Hierarchical Tasks Agent (2)",
                  "Untitled document (13)",
                  "Untitled document (14)",
                  "LangLang WPP Moderator ",
                  "Agent - Basic Langflow",
                  "Flow Avaliação Agente - Semana 3",
                  "Langflow GitHub Issue Scout",
                  "Document QA (1)",
                  "Agent - Basic Langflow - Live",
                  "4. Video Clip Processing",
                  "Untitled document (15)",
                  "Untitled document (15) (1)",
                  "Untitled document (16)",
                  "Sequential Tasks Agent (3)",
                  "Sequential Tasks Agent (4)",
                  "Untitled document (17)",
                  "Agent - Desafio 3",
                  "3_desafio_agente",
                  "Untitled document (18)",
                  "Untitled document (19)",
                  "Agent_desafio 3 (1)",
                  "Travel Planning Crew",
                  "Travel Agent Planner",
                  "Untitled document (20)",
                  "Vector Store RAG (2)",
                  "251bf984-53c6-4666-85ba-e91abc650b83",
                  "a6c6a078-5695-4a27-ae63-bd75bfbccfa7",
                  "a2461060-772c-4b6d-bae2-bc8d7bc14a9c",
                  "b18364fd-9ba0-4bc9-95a5-c0b35c9e50d2",
                  "bc81ff56-b115-49a1-bb4b-c3a8df5ac104",
                  "d994f3e0-b5f6-4f74-a75f-b93c50f78917",
                  "e777073c-b142-45e9-8f93-85938aeb81f0",
                  "f0c173e8-d694-4eb9-aac7-159300ebe54d",
                  "f091a2a7-7858-46db-b496-2d731fe3336f",
                  "0acf445f-856b-4575-9806-7dca45468299",
                  "5d467c16-667c-475d-bfae-4bd94ccdf946",
                  "7b251090-5711-49ea-b769-2ded6fb5e986",
                  "9a9c85ac-99dc-4fd5-8dda-bb4300411c1e"
                ],
                "combobox": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "flow_name",
                "value": "9a9c85ac-99dc-4fd5-8dda-bb4300411c1e",
                "display_name": "Flow Name",
                "advanced": false,
                "dynamic": false,
                "info": "The name of the flow to run.",
                "refresh_button": true,
                "title_case": false,
                "type": "str",
                "_input_type": "DropdownInput",
                "load_from_db": false
              },
              "user_name": {
                "trace_as_input": true,
                "trace_as_metadata": true,
                "load_from_db": false,
                "list": false,
                "required": false,
                "placeholder": "",
                "show": true,
                "name": "user_name",
                "value": "Paulo Henrique de Souza Salvatore",
                "display_name": "User Name",
                "advanced": false,
                "input_types": [
                  "Message"
                ],
                "dynamic": false,
                "info": "Full name of the user.",
                "title_case": false,
                "type": "str",
                "_input_type": "MessageInput"
              }
            },
            "description": "Execute a specific Langflow by name with a list of input messages, email address, and CPF.",
            "icon": "list-restart",
            "base_classes": [
              "Data"
            ],
            "display_name": "Batch Flow Executor - IA Devs",
            "documentation": "",
            "custom_fields": {},
            "output_types": [],
            "pinned": false,
            "conditional_paths": [],
            "frozen": false,
            "outputs": [
              {
                "types": [
                  "Data"
                ],
                "selected": "Data",
                "name": "output_data_list",
                "display_name": "Output Data List",
                "method": "execute_flow_batch",
                "value": "__UNDEFINED__",
                "cache": true
              }
            ],
            "field_order": [
              "input_data_list",
              "flow_name",
              "email_address",
              "cpf",
              "user_name"
            ],
            "beta": false,
            "edited": true,
            "lf_version": "1.0.15",
            "official": false
          },
          "id": "BatchFlowExecutorComponent-yQhKP",
          "description": "Execute a specific Langflow by name with a list of input messages, email address, and CPF.",
          "display_name": "Batch Flow Executor - IA Devs"
        },
        "id": "BatchFlowExecutorComponent-yQhKP",
        "position": {
          "x": 0,
          "y": 0
        },
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": 1,
      "y": 1,
      "zoom": 1
    }
  },
  "metadata": {
    "BatchFlowExecutorComponent": {
      "count": 1
    },
    "total": 1
  },
  "original": {
    "id": "5b3f6c06-8f0f-4fae-9d0c-6d217ce3c71a",
    "name": "Batch Flow Executor - IA Devs",
    "description": "Execute a specific Langflow by name with a list of input messages, email address, and CPF.",
    "is_component": true,
    "liked_by_count": "6",
    "downloads_count": "56",
    "metadata": {
      "BatchFlowExecutorComponent": {
        "count": 1
      },
      "total": 1
    },
    "last_tested_version": "1.0.15",
    "private": false,
    "data": {
      "edges": [],
      "nodes": [
        {
          "data": {
            "type": "BatchFlowExecutorComponent",
            "node": {
              "template": {
                "_type": "Component",
                "input_data_list": {
                  "trace_as_metadata": true,
                  "list": true,
                  "trace_as_input": true,
                  "required": false,
                  "placeholder": "",
                  "show": true,
                  "name": "input_data_list",
                  "value": "",
                  "display_name": "Input Data List",
                  "advanced": false,
                  "input_types": [
                    "Data"
                  ],
                  "dynamic": false,
                  "info": "A list of Data objects, each containing 'question' and 'ground_truth' keys to be passed to the flow.",
                  "title_case": false,
                  "type": "other",
                  "_input_type": "DataInput"
                },
                "code": {
                  "type": "code",
                  "required": true,
                  "placeholder": "",
                  "list": false,
                  "show": true,
                  "multiline": true,
                  "value": "import re\r\nimport json\r\nfrom typing import List, Any, Dict, Union, Optional\r\nfrom axiestudio.custom import Component\r\nfrom axiestudio.io import DataInput, Output, MessageInput, DropdownInput\r\nfrom axiestudio.schema import Data\r\nfrom loguru import logger\r\nimport langwatch\r\nimport aiohttp\r\nimport asyncio\r\nimport time\r\n\r\nclass BatchFlowExecutorComponent(Component):\r\n    display_name = \"Batch Flow Executor - IA Devs\"\r\n    description = \"Execute a specific Langflow by name with a list of input messages, email address, and CPF.\"\r\n    icon = \"list-restart\"\r\n    \r\n    LANGWATCH_API_KEY = \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0aW1lc3RhbXAiOjE3MjI2Mjc0NjM1MTMsInJhbmQiOjAuNjE5NzU0NDkyMjY5NzM0LCJpYXQiOjE3MjI2Mjc0NjN9._7Qb9ezb1Lk9KB8DNkwWivHestRwdkqxC15VgWxTXTg\"\r\n        \r\n    def get_flow_names(self) -> List[str]:\r\n        flow_data = self.list_flows()\r\n        return [flow_data.data[\"name\"] for flow_data in flow_data]\r\n\r\n    inputs = [\r\n        DataInput(\r\n            name=\"input_data_list\",\r\n            display_name=\"Input Data List\",\r\n            info=\"A list of Data objects, each containing 'question' and 'ground_truth' keys to be passed to the flow.\",\r\n            is_list=True,\r\n        ),\r\n        DropdownInput(\r\n            name=\"flow_name\",\r\n            display_name=\"Flow Name\",\r\n            info=\"The name of the flow to run.\",\r\n            options=[],\r\n            refresh_button=True,\r\n        ),\r\n        MessageInput(\r\n            name=\"email_address\",\r\n            display_name=\"Email Address\",\r\n            info=\"Email address for notifications or identification.\",\r\n        ),\r\n        MessageInput(\r\n            name=\"cpf\",\r\n            display_name=\"CPF\",\r\n            info=\"CPF for identification.\",\r\n        ),\r\n        MessageInput(\r\n            name=\"user_name\",\r\n            display_name=\"User Name\",\r\n            info=\"Full name of the user.\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(display_name=\"Output Data List\", name=\"output_data_list\", method=\"execute_flow_batch\"),\r\n    ]\r\n\r\n    def validate_email(self, email):\r\n        pattern = r'^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$'\r\n        return re.match(pattern, email) is not None\r\n\r\n    def validate_cpf(self, cpf):\r\n        if not re.match(r'^(?!(\\d)\\1{10})\\d{9}[\\d]{2}$', cpf):\r\n            return False\r\n        total = sum(int(cpf[i]) * (10 - i) for i in range(9))\r\n        check1 = (total * 10 % 11) % 10\r\n        total = sum(int(cpf[i]) * (11 - i) for i in range(10))\r\n        check2 = (total * 10 % 11) % 10\r\n        return cpf[-2:] == f\"{check1}{check2}\"\r\n\r\n    def update_build_config(self, build_config: dict, field_value: Any, field_name: str | None = None):\r\n        if field_name == \"flow_name\":\r\n            build_config[\"flow_name\"][\"options\"] = self.get_flow_names()\r\n        return build_config\r\n\r\n    @staticmethod\r\n    def extract_component_output(run_output: List[Any], component_name: str) -> Union[Dict[str, Any], None]:\r\n        if not run_output or not isinstance(run_output[0], object) or not hasattr(run_output[0], 'outputs'):\r\n            logger.error(f\"Invalid run_output structure: {run_output}\")\r\n            return None\r\n        \r\n        for output in run_output[0].outputs:\r\n            if hasattr(output, 'component_display_name') and component_name in output.component_display_name:\r\n                if 'Langwatch Evaluator' in output.component_display_name:\r\n                    trace_data = output.outputs.get('trace_url', {})\r\n                    logger.debug(\"Langwatch Evaluator DATA: \")\r\n                    logger.debug(trace_data)\r\n                    \r\n                    if isinstance(trace_data, dict):\r\n                        message = trace_data.get('message', {})\r\n                        if isinstance(message, dict):\r\n                            return {\r\n                                'trace_url': message.get('trace_url', ''),\r\n                                'flow_trace_id': message.get('flow_trace_id', ''),\r\n                                'eval_trace_id': message.get('eval_trace_id', '')\r\n                            }\r\n                        else:\r\n                            return {\r\n                                'trace_url': str(message),\r\n                                'flow_trace_id': '',\r\n                                'eval_trace_id': ''\r\n                            }\r\n                    elif isinstance(trace_data, str):\r\n                        try:\r\n                            trace_dict = json.loads(trace_data)\r\n                            message = trace_dict.get('message', {})\r\n                            return {\r\n                                'trace_url': message.get('trace_url', ''),\r\n                                'flow_trace_id': message.get('flow_trace_id', ''),\r\n                                'eval_trace_id': message.get('eval_trace_id', '')\r\n                            }\r\n                        except json.JSONDecodeError:\r\n                            logger.warning(f\"Failed to parse trace_url JSON: {trace_data}\")\r\n                            return {'trace_url': trace_data, 'flow_trace_id': '', 'eval_trace_id': ''}\r\n                    else:\r\n                        logger.warning(f\"Unexpected trace_url type: {type(trace_data)}\")\r\n                        return {'trace_url': str(trace_data), 'flow_trace_id': '', 'eval_trace_id': ''}\r\n                \r\n                elif 'Chat Output' in output.component_display_name:\r\n                    message = output.results.get('message', {})\r\n                    if isinstance(message, dict):\r\n                        return {\r\n                            'text': message.get('text', '')\r\n                        }\r\n                    elif hasattr(message, 'text'):\r\n                        return {\r\n                            'text': message.text\r\n                        }\r\n                    else:\r\n                        return {\r\n                            'text': str(message)\r\n                        }\r\n                        \r\n        logger.warning(f\"No matching output found for component: {component_name}\")\r\n        return None\r\n    \r\n    \r\n    async def fetch_evaluation(self, eval_trace_id: str) -> Dict[str, Any]:\r\n        url = f\"https://app.langwatch.ai/api/trace/{eval_trace_id}\"\r\n        headers = {\"X-Auth-Token\": self.LANGWATCH_API_KEY}\r\n        async with aiohttp.ClientSession() as session:\r\n            try:\r\n                async with session.get(url, headers=headers) as response:\r\n                    if response.status == 200:\r\n                        data = await response.json()\r\n                        evaluations = data.get('evaluations', [])\r\n                        if evaluations:\r\n                            evaluation = evaluations[0]\r\n                            return {\r\n                                \"passed\": evaluation.get('passed', False),\r\n                                \"details\": evaluation.get('details', \"Not able to fetch evaluation, check trace URL to see the result.\")\r\n                            }\r\n                        else:\r\n                            logger.warning(f\"No evaluations found for trace {eval_trace_id}\")\r\n                            return {\"passed\": False, \"details\": \"No evaluations found\"}\r\n                    else:\r\n                        logger.error(f\"Failed to retrieve trace info. Status: {response.status}\")\r\n                        return {\"passed\": False, \"details\": f\"API request failed with status {response.status}\"}\r\n            except aiohttp.ClientError as e:\r\n                logger.error(f\"Error occurred while retrieving trace info: {str(e)}\")\r\n                return {\"passed\": False, \"details\": f\"API request error: {str(e)}\"}\r\n    \r\n    async def fetch_metrics(self, flow_trace_id: str) -> Dict[str, Any]:\r\n        url = f\"https://app.langwatch.ai/api/trace/{flow_trace_id}\"\r\n        headers = {\"X-Auth-Token\": self.LANGWATCH_API_KEY}\r\n        async with aiohttp.ClientSession() as session:\r\n            try:\r\n                async with session.get(url, headers=headers) as response:\r\n                    if response.status == 200:\r\n                        data = await response.json()\r\n                        metrics = data.get('metrics', {})\r\n                        return {\r\n                            \"first_token_ms\": metrics.get('first_token_ms'),\r\n                            \"total_time_ms\": metrics.get('total_time_ms'),\r\n                            \"prompt_tokens\": metrics.get('prompt_tokens'),\r\n                            \"completion_tokens\": metrics.get('completion_tokens'),\r\n                            \"tokens_estimated\": metrics.get('tokens_estimated', False)\r\n                        }\r\n                    else:\r\n                        logger.error(f\"Failed to retrieve metrics. Status: {response.status}\")\r\n                        return {}\r\n            except aiohttp.ClientError as e:\r\n                logger.error(f\"Error occurred while retrieving metrics: {str(e)}\")\r\n                return {}\r\n\r\n    def get_flow(self, flow_name: str) -> Optional[Data]:\r\n        flow_datas = self.list_flows()\r\n        for flow_data in flow_datas:\r\n            if flow_data.data[\"name\"] == flow_name:\r\n                return flow_data\r\n        return None\r\n\r\n    def get_component_id_by_name(self, flow_name: str, component_name: str) -> str:\r\n        flow = self.get_flow(flow_name)\r\n        for node in flow.data.get(\"nodes\", []):\r\n            display_name = node.get(\"data\", {}).get(\"node\", {}).get(\"display_name\", \"\")\r\n            if display_name.startswith(component_name) or component_name in display_name:\r\n                return node.get(\"id\", \"\")\r\n        logger.warning(f\"Component starting with or containing '{component_name}' not found in flow '{flow_name}'\")\r\n        return \"\"\r\n\r\n    async def execute_flow_batch(self) -> List[Data]:\r\n        logger.info(\"Starting execute_flow_batch method\")\r\n        \r\n        langwatch.api_key = self.LANGWATCH_API_KEY\r\n\r\n        try:\r\n            email = self.email_address.text\r\n            cpf = self.cpf.text\r\n            user_name = self.user_name.text\r\n\r\n            if not self.validate_email(email):\r\n                raise ValueError(f\"Invalid email address: {email}\")\r\n            if not self.validate_cpf(cpf):\r\n                raise ValueError(f\"Invalid CPF: {cpf}\")\r\n            \r\n            flow_name = self._attributes.get(\"flow_name\")\r\n            \r\n            langwatch_evaluator_id = self.get_component_id_by_name(flow_name, \"Langwatch Evaluator\")\r\n            logger.debug(\"LANGWATCH EVALUATOR ID: \" + langwatch_evaluator_id)        \r\n            input_data_list = self.input_data_list\r\n            output_data_list = []\r\n            pending_evaluations = []\r\n\r\n            for index, input_data in enumerate(input_data_list, start=1):\r\n                logger.info(f\"Processing input data {index}/{len(input_data_list)}\")\r\n                if not isinstance(input_data, Data) or 'question' not in input_data.data:\r\n                    logger.warning(f\"Skipping invalid input data: {input_data}\")\r\n                    continue\r\n                \r\n                input_text = input_data.data['question']\r\n                question_id = input_data.data['id']\r\n                result = await self.run_flow(\r\n                    inputs={\"input_value\": input_text},\r\n                    flow_name=flow_name,\r\n                    tweaks={\r\n                        \"Langwatch Evaluator - Agent API\": {\r\n                            \"question_id\": question_id,\r\n                            \"user_email\": email,\r\n                            \"user_cpf\": cpf,\r\n                            \"user_name\": user_name\r\n                        },\r\n                    },\r\n                    output_type=\"debug\"\r\n                )\r\n                \r\n                logger.debug(f\"Run flow result: {result}\")\r\n                \r\n                chat_output = self.extract_component_output(result, \"Chat Output\")\r\n                langwatch_output = self.extract_component_output(result, \"Langwatch Evaluator\")\r\n                \r\n                response = chat_output['text'] if chat_output else \"Response not found\"\r\n                trace_url = langwatch_output.get('trace_url', \"Trace URL not found\") if langwatch_output else \"Trace URL not found\"\r\n                flow_trace_id = langwatch_output.get('flow_trace_id', \"\") if langwatch_output else \"\"\r\n                eval_trace_id = langwatch_output.get('eval_trace_id', \"\") if langwatch_output else \"\"\r\n                \r\n                output_data = Data(data={\r\n                    \"id\": question_id,\r\n                    \"question\": input_text,\r\n                    \"flow_response\": response,\r\n                    \"langwatch_trace_url\": trace_url,\r\n                    \"langwatch_flow_trace_id\": flow_trace_id,\r\n                    \"langwatch_eval_trace_id\": eval_trace_id,\r\n                })\r\n                output_data_list.append(output_data)\r\n                pending_evaluations.append((output_data, flow_trace_id, eval_trace_id))\r\n                logger.info(f\"Added output data for input {index}\")\r\n\r\n            logger.info(f\"Finished processing all inputs. Total outputs: {len(output_data_list)}\")\r\n            \r\n            # Wait for 15 seconds before fetching evaluations and metrics\r\n            logger.info(\"Waiting 15 seconds before fetching evaluations and metrics...\")\r\n            await asyncio.sleep(15)\r\n            \r\n            # Fetch evaluations and metrics for all flows\r\n            for output_data, flow_trace_id, eval_trace_id in pending_evaluations:\r\n                evaluation_results = await self.fetch_evaluation(eval_trace_id)\r\n                metrics_result = await self.fetch_metrics(flow_trace_id)\r\n                \r\n                logger.debug(f\"Evaluation results: {evaluation_results}\")\r\n                logger.debug(f\"Metrics result: {metrics_result}\")\r\n                \r\n                output_data.data.update({\r\n                    \"evaluation_passed\": evaluation_results[\"passed\"],\r\n                    \"evaluation_details\": evaluation_results[\"details\"],\r\n                    \"total_run_time_ms\": metrics_result.get(\"total_time_ms\"),\r\n                    \"prompt_tokens\": metrics_result.get(\"prompt_tokens\"),\r\n                    \"completion_tokens\": metrics_result.get(\"completion_tokens\"),\r\n                })\r\n\r\n            self.status = output_data_list\r\n            return output_data_list\r\n        \r\n        except ValueError as ve:\r\n            logger.error(f\"Validation error: {str(ve)}\")\r\n            self.status = str(ve)\r\n            raise ve\r\n            \r\n        except Exception as e:\r\n            error_message = f\"Error executing flow batch: {str(e)}\"\r\n            logger.error(error_message)\r\n            logger.exception(\"Full exception traceback:\")\r\n            self.status = error_message\r\n            return [Data(data={\"error\": error_message})]\r\n            \r\n        finally:\r\n            logger.info(\"Finished execute_flow_batch method\")",
                  "fileTypes": [],
                  "file_path": "",
                  "password": false,
                  "name": "code",
                  "advanced": true,
                  "dynamic": true,
                  "info": "",
                  "load_from_db": false,
                  "title_case": false
                },
                "cpf": {
                  "trace_as_input": true,
                  "trace_as_metadata": true,
                  "load_from_db": false,
                  "list": false,
                  "required": false,
                  "placeholder": "",
                  "show": true,
                  "name": "cpf",
                  "value": "43091004813",
                  "display_name": "CPF",
                  "advanced": false,
                  "input_types": [
                    "Message"
                  ],
                  "dynamic": false,
                  "info": "CPF for identification.",
                  "title_case": false,
                  "type": "str",
                  "_input_type": "MessageInput"
                },
                "email_address": {
                  "trace_as_input": true,
                  "trace_as_metadata": true,
                  "load_from_db": false,
                  "list": false,
                  "required": false,
                  "placeholder": "",
                  "show": true,
                  "name": "email_address",
                  "value": "salvatoregames@gmail.com",
                  "display_name": "Email Address",
                  "advanced": false,
                  "input_types": [
                    "Message"
                  ],
                  "dynamic": false,
                  "info": "Email address for notifications or identification.",
                  "title_case": false,
                  "type": "str",
                  "_input_type": "MessageInput"
                },
                "flow_name": {
                  "trace_as_metadata": true,
                  "options": [
                    "Competição Langflow Agent",
                    "CSV LLM Iterator (1)",
                    "url scraping (1)",
                    "Untitled document (6)",
                    "Topic Breaker",
                    "Untitled document (1)",
                    "Untitled document (2)",
                    "Memory Chatbot",
                    "Untitled document (3)",
                    "Untitled document (4)",
                    "Untitled document (5)",
                    "PDF Scraper",
                    "Langflow Component Helper",
                    "Prompt Chaining",
                    "Prompt Maker",
                    "Memory Chatbot (1)",
                    "prod - eval - semana 01",
                    "Memory Chatbot (2)",
                    "classify",
                    "Untitled document",
                    "desafio_semana_2_metodo_prompt_dinamico",
                    "EVAL COMPETICAO RAG",
                    "Chat FAQ",
                    "IA Devs - Desafio 1 - Dayvison Pellegrina",
                    "IA Devs - Desafio 1 - Chain v2 - Matheus S.",
                    "Untitled document (8)",
                    "IA Devs - Desafio 1 - Chain v2 - Matheus S. (1)",
                    "desafio_semana_2_metodo_prompt_dinamico (1)",
                    "desafio_semana_2_metodo_rag",
                    "Untitled document (9)",
                    "Sequential Tasks Agent",
                    "desafio_semana_2_metodo_rag  com ASTRA",
                    "Vector Store RAG",
                    "Experimento RAG - reranking e interador",
                    "Sequential Tasks Agent (1)",
                    "Hierarchical Tasks Agent",
                    "Untitled document (10)",
                    "IA Devs - Desafio 1 - Chain v2 - Matheus S. (2)",
                    "IA Devs - Desafio 1 - Chain v2 - Matheus S. (3)",
                    "Untitled document (11)",
                    "Vector Store RAG (1)",
                    "Basic Prompting (Hello, World)",
                    "Sequential Tasks Agent (2)",
                    "Document QA",
                    "Flow Avaliação Semana 2 - RAG ",
                    "testonho-semana2",
                    "Untitled document (7)",
                    "Untitled document (12)",
                    "24bd6b8a-0378-46ae-a95c-7cc85b024828 SW V2",
                    "Untitled document (1) (1)",
                    "Langflow Buddy",
                    "Memory Chatbot (3)",
                    "Hierarchical Tasks Agent (1)",
                    "Hierarchical Tasks Agent (2)",
                    "Untitled document (13)",
                    "Untitled document (14)",
                    "LangLang WPP Moderator ",
                    "Agent - Basic Langflow",
                    "Flow Avaliação Agente - Semana 3",
                    "Langflow GitHub Issue Scout",
                    "Document QA (1)",
                    "Agent - Basic Langflow - Live",
                    "4. Video Clip Processing",
                    "Untitled document (15)",
                    "Untitled document (15) (1)",
                    "Untitled document (16)",
                    "Sequential Tasks Agent (3)",
                    "Sequential Tasks Agent (4)",
                    "Untitled document (17)",
                    "Agent - Desafio 3",
                    "3_desafio_agente",
                    "Untitled document (18)",
                    "Untitled document (19)",
                    "Agent_desafio 3 (1)",
                    "Travel Planning Crew",
                    "Travel Agent Planner",
                    "Untitled document (20)",
                    "Vector Store RAG (2)",
                    "251bf984-53c6-4666-85ba-e91abc650b83",
                    "a6c6a078-5695-4a27-ae63-bd75bfbccfa7",
                    "a2461060-772c-4b6d-bae2-bc8d7bc14a9c",
                    "b18364fd-9ba0-4bc9-95a5-c0b35c9e50d2",
                    "bc81ff56-b115-49a1-bb4b-c3a8df5ac104",
                    "d994f3e0-b5f6-4f74-a75f-b93c50f78917",
                    "e777073c-b142-45e9-8f93-85938aeb81f0",
                    "f0c173e8-d694-4eb9-aac7-159300ebe54d",
                    "f091a2a7-7858-46db-b496-2d731fe3336f",
                    "0acf445f-856b-4575-9806-7dca45468299",
                    "5d467c16-667c-475d-bfae-4bd94ccdf946",
                    "7b251090-5711-49ea-b769-2ded6fb5e986",
                    "9a9c85ac-99dc-4fd5-8dda-bb4300411c1e"
                  ],
                  "combobox": false,
                  "required": false,
                  "placeholder": "",
                  "show": true,
                  "name": "flow_name",
                  "value": "9a9c85ac-99dc-4fd5-8dda-bb4300411c1e",
                  "display_name": "Flow Name",
                  "advanced": false,
                  "dynamic": false,
                  "info": "The name of the flow to run.",
                  "refresh_button": true,
                  "title_case": false,
                  "type": "str",
                  "_input_type": "DropdownInput",
                  "load_from_db": false
                },
                "user_name": {
                  "trace_as_input": true,
                  "trace_as_metadata": true,
                  "load_from_db": false,
                  "list": false,
                  "required": false,
                  "placeholder": "",
                  "show": true,
                  "name": "user_name",
                  "value": "Paulo Henrique de Souza Salvatore",
                  "display_name": "User Name",
                  "advanced": false,
                  "input_types": [
                    "Message"
                  ],
                  "dynamic": false,
                  "info": "Full name of the user.",
                  "title_case": false,
                  "type": "str",
                  "_input_type": "MessageInput"
                }
              },
              "description": "Execute a specific Langflow by name with a list of input messages, email address, and CPF.",
              "icon": "list-restart",
              "base_classes": [
                "Data"
              ],
              "display_name": "Batch Flow Executor - IA Devs",
              "documentation": "",
              "custom_fields": {},
              "output_types": [],
              "pinned": false,
              "conditional_paths": [],
              "frozen": false,
              "outputs": [
                {
                  "types": [
                    "Data"
                  ],
                  "selected": "Data",
                  "name": "output_data_list",
                  "display_name": "Output Data List",
                  "method": "execute_flow_batch",
                  "value": "__UNDEFINED__",
                  "cache": true
                }
              ],
              "field_order": [
                "input_data_list",
                "flow_name",
                "email_address",
                "cpf",
                "user_name"
              ],
              "beta": false,
              "edited": true,
              "lf_version": "1.0.15",
              "official": false
            },
            "id": "BatchFlowExecutorComponent-yQhKP",
            "description": "Execute a specific Langflow by name with a list of input messages, email address, and CPF.",
            "display_name": "Batch Flow Executor - IA Devs"
          },
          "id": "BatchFlowExecutorComponent-yQhKP",
          "position": {
            "x": 0,
            "y": 0
          },
          "type": "genericNode"
        }
      ],
      "viewport": {
        "x": 1,
        "y": 1,
        "zoom": 1
      }
    },
    "date_created": "2024-08-18T20:00:27.446Z",
    "date_updated": "2024-08-21T20:47:43.695Z",
    "status": "Public",
    "sort": null,
    "user_updated": "37095b75-b1f7-4e35-aea6-bcc9bbf1e2c7",
    "user_created": {
      "username": "NamastexLabs",
      "first_name": "Felipe",
      "last_name": "Rosa",
      "id": "37095b75-b1f7-4e35-aea6-bcc9bbf1e2c7"
    },
    "tags": []
  },
  "conversion": {
    "converted_at": "2025-08-19T18:09:10.213Z",
    "converted_from": "langflow",
    "converted_to": "axiestudio",
    "conversions_made": 6,
    "converter_version": "1.0.0"
  }
}