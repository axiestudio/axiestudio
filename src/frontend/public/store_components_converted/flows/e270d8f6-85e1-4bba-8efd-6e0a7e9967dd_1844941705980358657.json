{
  "id": "e270d8f6-85e1-4bba-8efd-6e0a7e9967dd",
  "name": "1844941705980358657",
  "description": "发票审核助手 (Converted from Langflow Store for AxieStudio compatibility)",
  "type": "FLOW",
  "is_component": false,
  "author": {
    "username": "huangxinghui",
    "first_name": "xinghui",
    "last_name": "huang",
    "id": "64bd3aa6-538a-4107-8754-c4a63e128385",
    "full_name": "xinghui huang"
  },
  "store_url": "https://www.langflow.store/store/component/e270d8f6-85e1-4bba-8efd-6e0a7e9967dd",
  "stats": {
    "downloads": 0,
    "likes": 0
  },
  "dates": {
    "created": "2024-10-12T07:18:38.413Z",
    "updated": "2024-10-12T07:18:38.684Z",
    "downloaded": "2025-08-19T17:50:07.598Z"
  },
  "tags": [],
  "technical": {
    "last_tested_version": "1.0.9",
    "private": false,
    "status": "Public"
  },
  "data": {
    "edges": [
      {
        "id": "reactflow__edge-ParseURL-CLLZq{œdataTypeœ:œParseURLœ,œidœ:œParseURL-CLLZqœ,œnameœ:œurl_textœ,œoutput_typesœ:[œMessageœ]}-UniBaoxiaoFile-wTUfp{œfieldNameœ:œexcelurlœ,œidœ:œUniBaoxiaoFile-wTUfpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "data": {
          "sourceHandle": {
            "id": "ParseURL-CLLZq",
            "name": "url_text",
            "dataType": "ParseURL",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "id": "UniBaoxiaoFile-wTUfp",
            "type": "str",
            "fieldName": "excelurl",
            "inputTypes": [
              "Message"
            ]
          }
        },
        "source": "ParseURL-CLLZq",
        "target": "UniBaoxiaoFile-wTUfp",
        "className": "",
        "sourceHandle": "{œdataTypeœ:œParseURLœ,œidœ:œParseURL-CLLZqœ,œnameœ:œurl_textœ,œoutput_typesœ:[œMessageœ]}",
        "targetHandle": "{œfieldNameœ:œexcelurlœ,œidœ:œUniBaoxiaoFile-wTUfpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "id": "reactflow__edge-ParseData-ocaSN{œdataTypeœ:œParseDataœ,œidœ:œParseData-ocaSNœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt-NYSg3{œfieldNameœ:œcontextœ,œidœ:œPrompt-NYSg3œ,œinputTypesœ:[œMessageœ,œTextœ],œtypeœ:œstrœ}",
        "data": {
          "sourceHandle": {
            "id": "ParseData-ocaSN",
            "name": "text",
            "dataType": "ParseData",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "id": "Prompt-NYSg3",
            "type": "str",
            "fieldName": "context",
            "inputTypes": [
              "Message",
              "Text"
            ]
          }
        },
        "source": "ParseData-ocaSN",
        "target": "Prompt-NYSg3",
        "className": "",
        "sourceHandle": "{œdataTypeœ:œParseDataœ,œidœ:œParseData-ocaSNœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "targetHandle": "{œfieldNameœ:œcontextœ,œidœ:œPrompt-NYSg3œ,œinputTypesœ:[œMessageœ,œTextœ],œtypeœ:œstrœ}"
      },
      {
        "id": "reactflow__edge-Prompt-NYSg3{œdataTypeœ:œPromptœ,œidœ:œPrompt-NYSg3œ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-UniTextInput-LJTY8{œfieldNameœ:œinput_valueœ,œidœ:œUniTextInput-LJTY8œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "data": {
          "sourceHandle": {
            "id": "Prompt-NYSg3",
            "name": "prompt",
            "dataType": "Prompt",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "id": "UniTextInput-LJTY8",
            "type": "str",
            "fieldName": "input_value",
            "inputTypes": [
              "Message"
            ]
          }
        },
        "source": "Prompt-NYSg3",
        "target": "UniTextInput-LJTY8",
        "className": "",
        "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-NYSg3œ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œUniTextInput-LJTY8œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "id": "reactflow__edge-UniTextInput-LJTY8{œdataTypeœ:œUniTextInputœ,œidœ:œUniTextInput-LJTY8œ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-OpenAICompatibleModel-cxm6H{œfieldNameœ:œinput_valueœ,œidœ:œOpenAICompatibleModel-cxm6Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "data": {
          "sourceHandle": {
            "id": "UniTextInput-LJTY8",
            "name": "text",
            "dataType": "UniTextInput",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "id": "OpenAICompatibleModel-cxm6H",
            "type": "str",
            "fieldName": "input_value",
            "inputTypes": [
              "Message"
            ]
          }
        },
        "source": "UniTextInput-LJTY8",
        "target": "OpenAICompatibleModel-cxm6H",
        "className": "",
        "sourceHandle": "{œdataTypeœ:œUniTextInputœ,œidœ:œUniTextInput-LJTY8œ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œOpenAICompatibleModel-cxm6Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "id": "reactflow__edge-WordFile-JYBuv{œdataTypeœ:œWordFileœ,œidœ:œWordFile-JYBuvœ,œnameœ:œchunksœ,œoutput_typesœ:[œDataœ]}-ParseData-ocaSN{œfieldNameœ:œdataœ,œidœ:œParseData-ocaSNœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
        "data": {
          "sourceHandle": {
            "id": "WordFile-JYBuv",
            "name": "chunks",
            "dataType": "WordFile",
            "output_types": [
              "Data"
            ]
          },
          "targetHandle": {
            "id": "ParseData-ocaSN",
            "type": "other",
            "fieldName": "data",
            "inputTypes": [
              "Data"
            ]
          }
        },
        "source": "WordFile-JYBuv",
        "target": "ParseData-ocaSN",
        "className": "",
        "sourceHandle": "{œdataTypeœ:œWordFileœ,œidœ:œWordFile-JYBuvœ,œnameœ:œchunksœ,œoutput_typesœ:[œDataœ]}",
        "targetHandle": "{œfieldNameœ:œdataœ,œidœ:œParseData-ocaSNœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
      },
      {
        "id": "reactflow__edge-UniBaoxiaoFile-wTUfp{œdataTypeœ:œUniBaoxiaoFileœ,œidœ:œUniBaoxiaoFile-wTUfpœ,œnameœ:œcontent2œ,œoutput_typesœ:[œMessageœ]}-Prompt-NYSg3{œfieldNameœ:œqueryœ,œidœ:œPrompt-NYSg3œ,œinputTypesœ:[œMessageœ,œTextœ],œtypeœ:œstrœ}",
        "data": {
          "sourceHandle": {
            "id": "UniBaoxiaoFile-wTUfp",
            "name": "content2",
            "dataType": "UniBaoxiaoFile",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "id": "Prompt-NYSg3",
            "type": "str",
            "fieldName": "query",
            "inputTypes": [
              "Message",
              "Text"
            ]
          }
        },
        "source": "UniBaoxiaoFile-wTUfp",
        "target": "Prompt-NYSg3",
        "className": "",
        "sourceHandle": "{œdataTypeœ:œUniBaoxiaoFileœ,œidœ:œUniBaoxiaoFile-wTUfpœ,œnameœ:œcontent2œ,œoutput_typesœ:[œMessageœ]}",
        "targetHandle": "{œfieldNameœ:œqueryœ,œidœ:œPrompt-NYSg3œ,œinputTypesœ:[œMessageœ,œTextœ],œtypeœ:œstrœ}"
      },
      {
        "id": "reactflow__edge-OpenAICompatibleModel-cxm6H{œdataTypeœ:œOpenAICompatibleModelœ,œidœ:œOpenAICompatibleModel-cxm6Hœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-UniChatOutput-hi43z{œfieldNameœ:œinput_valueœ,œidœ:œUniChatOutput-hi43zœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "data": {
          "sourceHandle": {
            "id": "OpenAICompatibleModel-cxm6H",
            "name": "text_output",
            "dataType": "OpenAICompatibleModel",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "id": "UniChatOutput-hi43z",
            "type": "str",
            "fieldName": "input_value",
            "inputTypes": [
              "Message"
            ]
          }
        },
        "source": "OpenAICompatibleModel-cxm6H",
        "target": "UniChatOutput-hi43z",
        "className": "",
        "sourceHandle": "{œdataTypeœ:œOpenAICompatibleModelœ,œidœ:œOpenAICompatibleModel-cxm6Hœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
        "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œUniChatOutput-hi43zœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      },
      {
        "id": "reactflow__edge-UniChatInput-ViEcc{œdataTypeœ:œUniChatInputœ,œidœ:œUniChatInput-ViEccœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-ParseURL-CLLZq{œfieldNameœ:œtextstr1œ,œidœ:œParseURL-CLLZqœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
        "data": {
          "sourceHandle": {
            "id": "UniChatInput-ViEcc",
            "name": "message",
            "dataType": "UniChatInput",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "id": "ParseURL-CLLZq",
            "type": "str",
            "fieldName": "textstr1",
            "inputTypes": [
              "Message"
            ]
          }
        },
        "source": "UniChatInput-ViEcc",
        "target": "ParseURL-CLLZq",
        "sourceHandle": "{œdataTypeœ:œUniChatInputœ,œidœ:œUniChatInput-ViEccœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
        "targetHandle": "{œfieldNameœ:œtextstr1œ,œidœ:œParseURL-CLLZqœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
      }
    ],
    "nodes": [
      {
        "id": "UniBaoxiaoFile-wTUfp",
        "data": {
          "id": "UniBaoxiaoFile-wTUfp",
          "node": {
            "beta": false,
            "icon": "file-text",
            "edited": false,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "content",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "method": "load_file",
                "selected": "Message",
                "display_name": "Content"
              },
              {
                "name": "content2",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "method": "load_url",
                "selected": "Message",
                "display_name": "url对应的Content"
              }
            ],
            "template": {
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "# -*- coding: utf-8 -*-\nfrom pathlib import Path\nimport os\nimport json\nfrom axiestudio.custom import Component\nfrom axiestudio.inputs import StrInput\nfrom axiestudio.io import FileInput, Output\nfrom axiestudio.schema.message import Message\nfrom axiestudio.schema import Data\nimport pandas as pd\nimport uuid\nimport requests\nfrom urllib.parse import urlparse\n\nclass UniBaoxiaoFileComponent(Component):\n    display_name = \"UniBaoxiaoFile\"\n    description = \"报销单解析\"\n    icon = \"file-text\"\n    name = \"UniBaoxiaoFile\"\n    \n    TEXT_FILE_TYPES=['xlsx','xls']\n    \n    inputs = [\n        StrInput(name=\"document_id\", display_name=\"文档ID\", value=\"None\"),\n        MultilineInput(name=\"excelurl\", display_name=\"文档url\",value=\"None\"),\n        FileInput(\n            name=\"path\",\n            display_name=\"Path\",\n            file_types=TEXT_FILE_TYPES,\n            info=f\"Supported file types: {', '.join(TEXT_FILE_TYPES)}\"\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"Content\", name=\"content\", method=\"load_file\"),\n        Output(display_name=\"url对应的Content\", name=\"content2\", method=\"load_url\"),\n    ]\n    \n    def download_file(self,url):\n        response = requests.get(url, stream=True,verify=False)\n        response.raise_for_status()\n        download_dir = 'download'\n        os.makedirs(download_dir, exist_ok=True)\n        file_name = os.path.basename(urlparse(url).path)\n        print(\"下载文件名是\",file_name)\n        file_path = os.path.join(download_dir, file_name)\n        print(\"下载文件路径是\",file_path)\n        with open(file_path, 'wb') as file:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:\n                    file.write(chunk)\n                #\n            #\n        #\n        return file_path\n    #enddef\n    \n    def load_file(self) -> Message:\n        if not self.path:\n            raise ValueError(\"请上传excel文件\")\n        #\n        a=self.path\n        document_url=self.resolve_path(self.path)\n        if(a.find('http:')>=0 or a.find('https:')>=0):\n            urltmp=a[a.find('http:'):].replace('\\\\','/').replace('http:/','http://')\n            if a.find('https:')>=0:\n                urltmp=a[a.find('https:'):].replace('\\\\','/').replace('https:/','https://')\n            #\n            print(urltmp)\n            document_url=urltmp\n            self.path=self.download_file(urltmp)\n        #endif\n        print(self.path)\n        resolved_path = self.resolve_path(self.path)\n        extension = Path(resolved_path).suffix[1:].lower()\n        print(extension)\n        if extension != \"xlsx\" and extension != \"xls\":\n            raise ValueError(\"The files are not supported. Please save as .xlsx\")\n        #end\n        #解析excel\n        file_path =resolved_path\n        file_name=file_path\n        if(file_path.find('/')>=0):\n            file_name = file_path.split(\"/\")[-1]\n        else:\n            file_name = file_path.split(\"\\\\\")[-1]\n        #endif\n        excel_data = pd.read_excel(file_path,skiprows=1,index_col=None)\n        rows=json.loads(excel_data.to_json(orient='records',force_ascii=False))\n        content_field=excel_data.columns.tolist()\n        items=[]\n        index=1\n        for row in rows:\n            #print(row)\n            title='费用类型_'+row['费用类型名称']+'（'+str(row['明细序号'])+'）'\n            bxcontent=title+':'+\"费用承担部门是'\"+row['费用承担部门名称']+\"', 费用类型是'\"+row['费用类型名称']\n            if(row['标题']):\n                bxcontent=bxcontent+\"', 摘要内容是'\"+row['标题']\n            #\n            if(row['费用申请部门名称']):\n                bxcontent=bxcontent+\"', 费用申请部门是'\"+row['费用申请部门名称']\n            #\n            if(row['企业账户名称']):\n                bxcontent=bxcontent+\"', 发票抬头是'\"+row['企业账户名称']\n            #\n            if(row['费用主体名称']):\n                bxcontent=bxcontent+\"', 报销单抬头是'\"+row['费用主体名称']\n            #\n            if(row['岗位预置名称']):\n                bxcontent=bxcontent+\"', 岗位类别是'\"+row['岗位预置名称']\n            #\n            if(row['科目名称']):\n                bxcontent=bxcontent+\"', 报销类型是'\"+row['科目名称']\n            #\n            if(row['账单日期']):\n                bxcontent=bxcontent+\"', 账单日期是'\"+row['账单日期']\n            #\n            if(row['报销日期']):\n                bxcontent=bxcontent+\"', 报销日期是'\"+row['报销日期']\n            #\n            if(row['发票日期']):\n                bxcontent=bxcontent+\"', 发票日期是'\"+row['发票日期']\n            #\n            if(row['费用金额']>0):\n                bxcontent=bxcontent+\"', 费用金额是\"+str(row['费用金额'])+\"元\"\n            #\n            #if(row['报销金额']>0):\n            #    bxcontent=bxcontent+\"', 报销金额是'\"+str(row['报销金额'])+\"元'\"\n            #\n            #print(bxcontent)\n            items.append(bxcontent)\n            index=index+1\n        #endfor\n        allresult='\\n\\n'.join(items)\n        self.status = allresult\n        os.remove(self.path)\n        return allresult\n    #\n    def load_url(self) -> Message:\n        if(self.excelurl=='None'):\n            raise ValueError(\"缺少报销单url地址，请提供报销单的url\")\n        #endif\n        self.path=self.download_file(self.excelurl)\n        resolved_path = self.resolve_path(self.path)\n        extension = Path(resolved_path).suffix[1:].lower()\n        print(extension)\n        if extension != \"xlsx\" and extension != \"xls\":\n            raise ValueError(\"The files are not supported. Please save as .xlsx\")\n        #end\n        #解析excel\n        file_path =resolved_path\n        file_name=file_path\n        if(file_path.find('/')>=0):\n            file_name = file_path.split(\"/\")[-1]\n        else:\n            file_name = file_path.split(\"\\\\\")[-1]\n        #endif\n        excel_data = pd.read_excel(file_path,skiprows=1,index_col=None)\n        rows=json.loads(excel_data.to_json(orient='records',force_ascii=False))\n        content_field=excel_data.columns.tolist()\n        items=[]\n        index=1\n        for row in rows:\n            #print(row)\n            title='费用类型_'+row['费用类型名称']+'（'+str(row['明细序号'])+'）'\n            bxcontent=title+':'+\"费用承担部门是'\"+row['费用承担部门名称']+\"', 费用类型是'\"+row['费用类型名称']\n            if(row['标题']):\n                bxcontent=bxcontent+\"', 摘要内容是'\"+row['标题']\n            #\n            if(row['费用申请部门名称']):\n                bxcontent=bxcontent+\"', 费用申请部门是'\"+row['费用申请部门名称']\n            #\n            if(row['企业账户名称']):\n                bxcontent=bxcontent+\"', 发票抬头是'\"+row['企业账户名称']\n            #\n            if(row['费用主体名称']):\n                bxcontent=bxcontent+\"', 报销单抬头是'\"+row['费用主体名称']\n            #\n            if(row['岗位预置名称']):\n                bxcontent=bxcontent+\"', 岗位类别是'\"+row['岗位预置名称']\n            #\n            if(row['科目名称']):\n                bxcontent=bxcontent+\"', 报销类型是'\"+row['科目名称']\n            #\n            if(row['账单日期']):\n                bxcontent=bxcontent+\"', 账单日期是'\"+row['账单日期']\n            #\n            if(row['报销日期']):\n                bxcontent=bxcontent+\"', 报销日期是'\"+row['报销日期']\n            #\n            if(row['发票日期']):\n                bxcontent=bxcontent+\"', 发票日期是'\"+row['发票日期']\n            #\n            if(row['费用金额']>0):\n                bxcontent=bxcontent+\"', 费用金额是\"+str(row['费用金额'])+\"元\"\n            #\n            #if(row['报销金额']>0):\n            #    bxcontent=bxcontent+\"', 报销金额是'\"+str(row['报销金额'])+\"元'\"\n            #\n            #print(bxcontent)\n            items.append(bxcontent)\n            index=index+1\n        #endfor\n        allresult='\\n\\n'.join(items)\n        self.status = allresult\n        os.remove(self.path)\n        return allresult\n    #\n#\n",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "path": {
                "info": "Supported file types: xlsx, xls",
                "list": false,
                "name": "path",
                "show": true,
                "type": "file",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "fileTypes": [
                  "xlsx",
                  "xls"
                ],
                "file_path": "",
                "title_case": false,
                "placeholder": "",
                "display_name": "Path",
                "trace_as_metadata": true
              },
              "_type": "Component",
              "excelurl": {
                "info": "",
                "list": false,
                "name": "excelurl",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "multiline": true,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "文档url",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "document_id": {
                "info": "",
                "list": false,
                "name": "document_id",
                "show": true,
                "type": "str",
                "value": "None",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "文档ID",
                "load_from_db": false,
                "trace_as_metadata": true
              }
            },
            "description": "报销单解析",
            "field_order": [
              "document_id",
              "excelurl",
              "path"
            ],
            "base_classes": [
              "Message"
            ],
            "display_name": "UniBaoxiaoFile",
            "output_types": [],
            "custom_fields": {},
            "documentation": "",
            "conditional_paths": []
          },
          "type": "UniBaoxiaoFile",
          "description": "报销单解析",
          "display_name": "UniBaoxiaoFile"
        },
        "type": "genericNode",
        "width": 384,
        "height": 529,
        "dragging": false,
        "position": {
          "x": -797.3742033098308,
          "y": 735.6803663468979
        },
        "selected": false,
        "positionAbsolute": {
          "x": -797.3742033098308,
          "y": 735.6803663468979
        }
      },
      {
        "id": "ParseURL-CLLZq",
        "data": {
          "id": "ParseURL-CLLZq",
          "node": {
            "beta": false,
            "icon": "/zy-icons/UniCombineTextComponent.png",
            "edited": false,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "url_text",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "method": "geturl",
                "selected": "Message",
                "display_name": "url"
              }
            ],
            "template": {
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "# -*- coding: utf-8 -*-\nfrom axiestudio.custom import Component\nfrom axiestudio.io import MessageTextInput, Output\nfrom axiestudio.schema.message import Message\nfrom axiestudio.utils.MinioUtils import MinioUtils\nimport re\n\nclass ParseURLComponent(Component):\n    display_name = \"获取字符串中的url\"\n    description = \"获取字符串中的url\"\n    icon = \"merge\"\n    name = \"ParseURL\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"textstr1\",\n            display_name=\"文本\",\n            info=\"文本\"\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"url\", name=\"url_text\", method=\"geturl\"),\n    ]\n    \n    def extract_urls(self,text):\n        url_pattern = r'https?://[^\\s]+'\n        urls = re.findall(url_pattern, text)\n        return urls\n    #\n    def __init__(self, **kwargs):\n        # 调用父类的初始化方法\n        super().__init__(**kwargs)\n        self.icon= MinioUtils().get_full_path('zy-icons', 'UniCombineTextComponent.png')\n    def geturl(self) -> Message:\n        extracted_urls = self.extract_urls(self.textstr1)\n        if len(extracted_urls)>0:\n            myurl=extracted_urls[0]\n            self.status =myurl\n            return Message(text=myurl)\n        else:\n            self.status ='None'\n            return Message(text='None')\n        #endif\n    #\n#\n",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "_type": "Component",
              "textstr1": {
                "info": "文本",
                "list": false,
                "name": "textstr1",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "文本",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              }
            },
            "description": "获取字符串中的url",
            "field_order": [
              "textstr1"
            ],
            "base_classes": [
              "Message"
            ],
            "display_name": "获取字符串中的url",
            "output_types": [],
            "custom_fields": {},
            "documentation": "",
            "conditional_paths": []
          },
          "type": "ParseURL"
        },
        "type": "genericNode",
        "width": 384,
        "height": 309,
        "dragging": false,
        "position": {
          "x": -1305.6186941068,
          "y": 424.44929241865594
        },
        "selected": false,
        "positionAbsolute": {
          "x": -1305.6186941068,
          "y": 424.44929241865594
        }
      },
      {
        "id": "Prompt-NYSg3",
        "data": {
          "id": "Prompt-NYSg3",
          "node": {
            "beta": false,
            "icon": "prompts",
            "name": "",
            "error": null,
            "edited": false,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "prompt",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "hidden": null,
                "method": "build_prompt",
                "selected": "Message",
                "display_name": "Prompt Message"
              }
            ],
            "is_input": null,
            "template": {
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "from axiestudio.base.prompts.api_utils import process_prompt_template\nfrom axiestudio.custom import Component\nfrom axiestudio.io import Output, PromptInput\nfrom axiestudio.schema.message import Message\nfrom axiestudio.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(\n        self,\n    ) -> Message:\n        prompt = await Message.from_template_and_variables(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def post_code_processing(self, new_build_config: dict, current_build_config: dict):\n        \"\"\"\n        This function is called after the code validation is done.\n        \"\"\"\n        frontend_node = super().post_code_processing(new_build_config, current_build_config)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_build_config\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_build_config[\"template\"])\n        return frontend_node\n",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "_type": "Component",
              "query": {
                "info": "",
                "list": false,
                "name": "query",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "password": false,
                "required": false,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "field_type": "str",
                "title_case": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "placeholder": "",
                "display_name": "query",
                "load_from_db": false
              },
              "context": {
                "info": "",
                "list": false,
                "name": "context",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "password": false,
                "required": false,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "field_type": "str",
                "title_case": false,
                "input_types": [
                  "Message",
                  "Text"
                ],
                "placeholder": "",
                "display_name": "context",
                "load_from_db": false
              },
              "template": {
                "info": "",
                "list": false,
                "name": "template",
                "show": true,
                "type": "prompt",
                "value": "1. 根据提供的报销规则如下：\n{context}\n---------------------------------------------------------\n2. 报销条目如下：\n---------------------------------------------------------\n【{query}】\n---------------------------------------------------------\n3. 对上面多条报销逐一进行合规性检查，并给出结论。",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "Template",
                "load_from_db": false,
                "trace_as_input": true
              }
            },
            "full_path": null,
            "is_output": null,
            "description": "Create a prompt template with dynamic variables.",
            "field_order": [
              "template"
            ],
            "base_classes": [
              "Message"
            ],
            "display_name": "Prompt",
            "output_types": [],
            "custom_fields": {
              "template": [
                "context",
                "query"
              ]
            },
            "documentation": "",
            "is_composition": null,
            "conditional_paths": []
          },
          "type": "Prompt",
          "description": "Create a prompt template with dynamic variables.",
          "display_name": "Prompt"
        },
        "type": "genericNode",
        "width": 384,
        "height": 517,
        "dragging": false,
        "position": {
          "x": -1027.5202725078598,
          "y": 1380.9370385186064
        },
        "selected": false,
        "positionAbsolute": {
          "x": -1027.5202725078598,
          "y": 1380.9370385186064
        }
      },
      {
        "id": "ParseData-ocaSN",
        "data": {
          "id": "ParseData-ocaSN",
          "node": {
            "beta": false,
            "icon": "braces",
            "edited": false,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "text",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "method": "parse_data",
                "selected": "Message",
                "display_name": "Text"
              }
            ],
            "template": {
              "sep": {
                "info": "",
                "list": false,
                "name": "sep",
                "show": true,
                "type": "str",
                "value": "\n",
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "Separator",
                "load_from_db": false,
                "trace_as_metadata": true
              },
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "from axiestudio.custom import Component\nfrom axiestudio.helpers.data import data_to_text\nfrom axiestudio.io import DataInput, MultilineInput, Output, StrInput\nfrom axiestudio.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\"),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"parse_data\"),\n    ]\n\n    def parse_data(self) -> Message:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n\n        result_string = data_to_text(template, data, sep=self.sep)\n        self.status = result_string\n        return Message(text=result_string)\n",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "data": {
                "info": "The data to convert to text.",
                "list": false,
                "name": "data",
                "show": true,
                "type": "other",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Data"
                ],
                "placeholder": "",
                "display_name": "Data",
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "_type": "Component",
              "template": {
                "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                "list": false,
                "name": "template",
                "show": true,
                "type": "str",
                "value": "{text}",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "multiline": true,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "Template",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              }
            },
            "description": "Convert Data into plain text following a specified template.",
            "field_order": [
              "data",
              "template",
              "sep"
            ],
            "base_classes": [
              "Message"
            ],
            "display_name": "Parse Data",
            "output_types": [],
            "custom_fields": {},
            "documentation": "",
            "conditional_paths": []
          },
          "type": "ParseData"
        },
        "type": "genericNode",
        "width": 384,
        "height": 385,
        "dragging": false,
        "position": {
          "x": -1472.0572270984728,
          "y": 1202.2056856419683
        },
        "selected": false,
        "positionAbsolute": {
          "x": -1472.0572270984728,
          "y": 1202.2056856419683
        }
      },
      {
        "id": "OpenAICompatibleModel-cxm6H",
        "data": {
          "id": "OpenAICompatibleModel-cxm6H",
          "node": {
            "beta": false,
            "icon": "OpenAI",
            "edited": false,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "text_output",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "method": "text_response",
                "selected": "Message",
                "display_name": "文本"
              },
              {
                "name": "model_output",
                "cache": true,
                "types": [
                  "LanguageModel"
                ],
                "value": "__UNDEFINED__",
                "method": "build_model",
                "selected": "LanguageModel",
                "display_name": "语言模型"
              }
            ],
            "template": {
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "# -*- coding: utf-8 -*-\nimport os\nimport operator\nfrom functools import reduce\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\nfrom langfuse import Langfuse\nfrom axiestudio.base.constants import STREAM_INFO_TEXT\nfrom axiestudio.base.models.model import LCModelComponent\nfrom axiestudio.base.models.openai_constants import MODEL_NAMES\nfrom axiestudio.field_typing import LanguageModel\nfrom axiestudio.inputs import (\n    BoolInput,\n    DictInput,\n    DropdownInput,\n    FloatInput,\n    IntInput,\n    MessageInput,\n    SecretStrInput,\n    StrInput,\n)\n\nfrom langchain_core.language_models.llms import LLM\nfrom langchain_core.messages import AIMessage, BaseMessage, HumanMessage, SystemMessage\nfrom axiestudio.custom import Component\nfrom axiestudio.schema.message import Message\nfrom axiestudio.template.field.base import Output\nimport json\nimport warnings\nfrom typing import Optional, Union\n\n\nclass OpenAICompatibleModelComponent(LCModelComponent):\n    display_name = \"OpenAI Compatible\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAICompatibleModel\"\n\n    inputs = [\n        MessageInput(name=\"input_value\", display_name=\"Input\",value=\"hello\"),\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        StrInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            info=\"the model name. Defaults to 'chatglm3' if not specified.\",\n            value=\"chatglm3\",\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            value=\"http://10.0.50.33:9997/v1\",\n            info=\"The base URL of the OpenAI compatible API. Defaults to http://10.0.50.33:9997/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        StrInput(\n            name=\"openai_api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            value=\"sk-2c3a4cb458884f9897529d26a44f403f\",\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        BoolInput(name=\"stream\", display_name=\"Stream\", info=STREAM_INFO_TEXT, advanced=True),\n        StrInput(\n            name=\"system_message\",\n            display_name=\"System Message\",\n            info=\"System message to pass to the model.\",\n            advanced=True,\n        )\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        # self.output_schea is a list of dictionarie s\n        myopenai_api_key = self.openai_api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        openai_api_base = self.openai_api_base or \"http://10.0.50.33:9997/v1\"\n        try:\n            output = ChatOpenAI(model=model_name,base_url=openai_api_base,openai_api_base=openai_api_base,openai_api_key=myopenai_api_key,model_name=model_name,openai_proxy=\"\",temperature=temperature)\n        except Exception as e:\n            raise ValueError(\"Could not initialize ChatOpenAI LLM.\") from e\n        #\n        return output  # type: ignore\n    #end\n    def text_response(self) -> Message:\n        input_value = self.input_value\n        stream = self.stream\n        system_message = self.system_message\n        output = self.build_model()\n        result = self.get_chat_result(output, stream, input_value, system_message)\n        self.status = result\n        return result\n    #\n    \n    def get_chat_result(\n        self,\n        runnable: LanguageModel,\n        stream: bool,\n        input_value: str | Message,\n        system_message: Optional[str] = None,\n    ):\n        messages: list[Union[BaseMessage]] = []\n        if not input_value and not system_message:\n            raise ValueError(\"The message you want to send to the model is empty.\")\n        if system_message:\n            messages.append(SystemMessage(content=system_message))\n        if input_value:\n            if isinstance(input_value, Message):\n                with warnings.catch_warnings():\n                    warnings.simplefilter(\"ignore\")\n                    if \"prompt\" in input_value:\n                        prompt = input_value.load_lc_prompt()\n                        runnable = prompt | runnable\n                    else:\n                        messages.append(input_value.to_lc_message())\n                    #\n            else:\n                messages.append(HumanMessage(content=input_value))\n        inputs: Union[list, dict] = messages or {}\n        try:\n            runnable = runnable.with_config( \n                {\"run_name\": self.display_name, \"project_name\": self.tracing_service.project_name}\n            )\n            if stream:\n                return runnable.stream(inputs) \n            else:\n                #myLangfuse = Langfuse(secret_key=\"sk-lf-56f301e0-82c4-44c3-bee2-7bac283c984b\",public_key=\"pk-lf-96f4a175-d1f9-4a69-9d8f-f0559228fbb7\",host=\"http://10.0.53.214:3000\")\n                myLangfuse = Langfuse(secret_key=os.getenv(\"LANGFUSE_SECRET_KEY\"),public_key=os.getenv(\"LANGFUSE_PUBLIC_KEY\"),host=os.getenv(\"LANGFUSE_HOST\"))\n                trace = myLangfuse.trace(name='大模型trace',user_id=\"LLM\")\n                langfuse_handler_trace = trace.get_langchain_handler()\n                message = runnable.invoke(inputs,config={\"callbacks\": [langfuse_handler_trace]})\n                result = message.content if hasattr(message, \"content\") else message\n                if isinstance(message, AIMessage):\n                    status_message = self.build_status_message(message)\n                    self.status = status_message\n                elif isinstance(result, dict):\n                    result = json.dumps(message, indent=4)\n                    self.status = result\n                else:\n                    self.status = result\n                return result\n        except Exception as e:\n            if message := self._get_exception_message(e):\n                raise ValueError(message) from e\n            raise e\n        #\n    #def",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "_type": "Component",
              "stream": {
                "info": "Stream the response from the model. Streaming works only in Chat.",
                "list": false,
                "name": "stream",
                "show": true,
                "type": "bool",
                "value": false,
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "Stream",
                "trace_as_metadata": true
              },
              "max_tokens": {
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "name": "max_tokens",
                "show": true,
                "type": "int",
                "value": "",
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "Max Tokens",
                "trace_as_metadata": true
              },
              "model_name": {
                "info": "the model name. Defaults to 'chatglm3' if not specified.",
                "list": false,
                "name": "model_name",
                "show": true,
                "type": "str",
                "value": "glm4-chat",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "Model Name",
                "load_from_db": false,
                "trace_as_metadata": true
              },
              "input_value": {
                "info": "",
                "list": false,
                "name": "input_value",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "Input",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "temperature": {
                "info": "",
                "list": false,
                "name": "temperature",
                "show": true,
                "type": "float",
                "value": 0.1,
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "Temperature",
                "trace_as_metadata": true
              },
              "openai_api_key": {
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "list": false,
                "name": "openai_api_key",
                "show": true,
                "type": "str",
                "value": "sk-2c3a4cb458884f9897529d26a44f403f",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "OpenAI API Key",
                "load_from_db": false,
                "trace_as_metadata": true
              },
              "system_message": {
                "info": "System message to pass to the model.",
                "list": false,
                "name": "system_message",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "System Message",
                "load_from_db": false,
                "trace_as_metadata": true
              },
              "openai_api_base": {
                "info": "The base URL of the OpenAI compatible API. Defaults to http://10.0.50.33:9997/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "list": false,
                "name": "openai_api_base",
                "show": true,
                "type": "str",
                "value": "http://10.0.50.33:9997/v1",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "OpenAI API Base",
                "load_from_db": false,
                "trace_as_metadata": true
              }
            },
            "description": "Generates text using OpenAI LLMs.",
            "field_order": [
              "input_value",
              "max_tokens",
              "model_name",
              "openai_api_base",
              "openai_api_key",
              "temperature",
              "stream",
              "system_message"
            ],
            "base_classes": [
              "LanguageModel",
              "Message"
            ],
            "display_name": "OpenAI Compatible",
            "output_types": [],
            "custom_fields": {},
            "documentation": "",
            "conditional_paths": []
          },
          "type": "OpenAICompatibleModel"
        },
        "type": "genericNode",
        "width": 384,
        "height": 701,
        "dragging": false,
        "position": {
          "x": -75.10016220370642,
          "y": 1410.8826071652743
        },
        "selected": false,
        "positionAbsolute": {
          "x": -75.10016220370642,
          "y": 1410.8826071652743
        }
      },
      {
        "id": "UniTextInput-LJTY8",
        "data": {
          "id": "UniTextInput-LJTY8",
          "node": {
            "beta": false,
            "icon": "/zy-icons/UniTextInputComponent.png",
            "edited": false,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "text",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "method": "text_response",
                "selected": "Message",
                "display_name": "文本"
              }
            ],
            "template": {
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "# -*- coding: utf-8 -*-\nfrom axiestudio.base.io.text import TextComponent\nfrom axiestudio.io import MessageTextInput, Output\nfrom axiestudio.schema.message import Message\nfrom axiestudio.utils.MinioUtils import MinioUtils\n\nclass UniTextInputComponent(TextComponent):\n    display_name = \"文本输入\"\n    description = \"从调试窗口获得文本输入。\"\n    icon = \"type\"\n    name = \"UniTextInput\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"文本\",\n            info=\"要作为输入的文本。\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"文本\", name=\"text\", method=\"text_response\"),\n    ]\n    def __init__(self, **kwargs):\n        # 调用父类的初始化方法\n        super().__init__(**kwargs)\n        self.icon= MinioUtils().get_full_path('zy-icons', 'UniTextInputComponent.png')\n    def text_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n        )\n        return message\n",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "_type": "Component",
              "input_value": {
                "info": "要作为输入的文本。",
                "list": false,
                "name": "input_value",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "文本",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              }
            },
            "description": "从调试窗口获得文本输入。",
            "field_order": [
              "input_value"
            ],
            "base_classes": [
              "Message"
            ],
            "display_name": "文本输入",
            "output_types": [],
            "custom_fields": {},
            "documentation": "",
            "conditional_paths": []
          },
          "type": "UniTextInput"
        },
        "type": "genericNode",
        "width": 384,
        "height": 309,
        "dragging": false,
        "position": {
          "x": -576.1338612101653,
          "y": 1529.812811799556
        },
        "selected": false,
        "positionAbsolute": {
          "x": -576.1338612101653,
          "y": 1529.812811799556
        }
      },
      {
        "id": "WordFile-JYBuv",
        "data": {
          "id": "WordFile-JYBuv",
          "node": {
            "beta": false,
            "icon": "file-text",
            "edited": true,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "chunks",
                "cache": true,
                "types": [
                  "Data"
                ],
                "value": "__UNDEFINED__",
                "method": "load_file",
                "selected": "Data",
                "display_name": "Chunks"
              }
            ],
            "template": {
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "# -*- coding: utf-8 -*-\nfrom pathlib import Path\nimport re\nimport os\nimport subprocess\nfrom langchain.docstore.document import Document\nfrom axiestudio.base.data.utils import TEXT_FILE_TYPES, parse_text_file_to_data\nfrom axiestudio.custom import Component\nfrom axiestudio.inputs import IntInput, StrInput\nfrom axiestudio.io import BoolInput, FileInput, Output,DropdownInput\nfrom axiestudio.schema import Data\n\nfrom docx import Document as docx_Document\nfrom docx.oxml import CT_P, CT_Tbl, CT_Inline\nfrom docx.text.paragraph import Paragraph\nfrom docx.table import Table\nfrom PIL import Image\nfrom io import BytesIO\nfrom rapidocr_onnxruntime import RapidOCR\nfrom enum import Enum\nimport uuid\nfrom typing import List, Optional, Any\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nimport requests\nfrom urllib.parse import urlparse\n\n\nclass WordFileComponent(Component):\n    display_name = \"WordFile\"\n    description = \"A word file loader.\"\n    icon = \"file-text\"\n    name = \"WordFile\"\n    TEXT_FILE_TYPES=['docx','doc']\n    inputs = [\n        StrInput(name=\"document_id\", display_name=\"文档ID\", value=\"http://10.0.53.245:9000/sysconfig/%E7%B4%AB%E5%85%89%E4%BA%91%E6%8A%A5%E9%94%80%E5%88%B6%E5%BA%A6.docx\"),\n        FileInput(\n            name=\"path\",\n            display_name=\"Path\",\n            file_types=TEXT_FILE_TYPES,\n            info=f\"Supported file types: {', '.join(TEXT_FILE_TYPES)}\",\n            required=True\n        ),\n        BoolInput(name=\"is_ocr\", display_name=\"光学字符识别\",value=True),\n        DropdownInput(\n            name=\"split_strategy\",\n            display_name=\"切片策略\",\n            options=[\n                \"默认切分\",\n                \"自定义切片\",\n                \"整文件切片\"\n            ],\n            required=True\n        ),\n        IntInput(name=\"chunk_size\", display_name=\"切片最大长度\", value=500),\n        IntInput(name=\"chunk_overlap\", display_name=\"切片重叠最大字数\", value=50),\n        StrInput(\n            name=\"separators\",\n            display_name=\"separators\",\n            info=\"The character to split on. Defaults to newline.\",\n            value=\"\\\\n\\\\n,\\\\n,。|！|？\",\n        ),\n        BoolInput(\n            name=\"silent_errors\",\n            display_name=\"Silent Errors\",\n            advanced=True,\n            info=\"If true, errors will not raise an exception.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Chunks\", name=\"chunks\", method=\"load_file\"),\n    ]\n    \n    def download_file(self,url):\n        response = requests.get(url, stream=True,verify=False)\n        response.raise_for_status()\n        download_dir = 'download'\n        os.makedirs(download_dir, exist_ok=True)\n        file_name = os.path.basename(urlparse(url).path)\n        print(\"下载文件名是\",file_name)\n        file_path = os.path.join(download_dir, file_name)\n        print(\"下载文件路径是\",file_path)\n        with open(file_path, 'wb') as file:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:\n                    file.write(chunk)\n                #\n            #\n        #\n        return file_path\n    #enddef\n\n    def load_file(self) -> List[Data]:\n        class TableTitleDirection(Enum):\n            Row = 1,\n            Column = 2\n        #\n\n        class TableContentSpltterStyle(Enum):\n            ByRow = 1,\n            ByColumn = 2,\n            TitleJoinContent = 3\n        class TableConfig:\n            def __init__(self,\n                         has_titles: bool = True,\n                         ignore_titles: bool = False,\n                         titles_direction: TableTitleDirection = TableTitleDirection.Row,\n                         table_content_splitter_style: TableContentSpltterStyle = TableContentSpltterStyle.ByRow):\n                super().__init__()\n                self.has_titles = has_titles\n                self.ignore_titles = ignore_titles\n                self.titles_direction = titles_direction\n                self.table_content_splitter_style = table_content_splitter_style\n            #\n        #\n        class Chunk():\n            content: str\n            index: int\n            count: int\n\n            def __init__(self, content: str, count: int = 1, index: int = 0) -> None:\n                # super().__init__(content=content, count=count, index=index)\n                self.content = content\n                self.count = count\n                self.index = index\n            #\n        #\n\n        class ChineseRecursiveTextSplitter(RecursiveCharacterTextSplitter):\n            def __init__(\n                    self,\n                    separators: Optional[List[str]] = None,\n                    keep_separator: bool = True,\n                    is_separator_regex: bool = True,\n                    **kwargs: Any,\n            ) -> None:\n                \"\"\"Create a new TextSplitter.\"\"\"\n                super().__init__(keep_separator=keep_separator, **kwargs)\n                self._separators = separators or [\n                    \"\\n\\n\",\n                    \"\\n\",\n                    \"。|！|？\",\n                    r\"\\.\\s|\\!\\s|\\?\\s\",\n                    r\"；|;\\s\",\n                    r\"，|,\\s\"\n                ]\n                self._is_separator_regex = is_separator_regex\n            #\n            \n            def _split_text_with_regex_from_end(self,text: str, separator: str, keep_separator: bool) -> List[str]:\n                # Now that we have the separator, split the text\n                if separator:\n                    if keep_separator:\n                        # The parentheses in the pattern keep the delimiters in the result.\n                        _splits = re.split(f\"({separator})\", text)\n                        splits = [\"\".join(i) for i in zip(_splits[0::2], _splits[1::2])]\n                        if len(_splits) % 2 == 1:\n                            splits += _splits[-1:]\n                        # splits = [_splits[0]] + splits\n                    else:\n                        splits = re.split(separator, text)\n                else:\n                    splits = list(text)\n                return [s for s in splits if s != \"\"]\n            #\n            def _split_text(self, text: str, separators: List[str]) -> List[str]:\n                \"\"\"Split incoming text and return chunks.\"\"\"\n                final_chunks = []\n                # Get appropriate separator to use\n                separator = separators[-1]\n                new_separators = []\n                for i, _s in enumerate(separators):\n                    _separator = _s if self._is_separator_regex else re.escape(_s)\n                    if _s == \"\":\n                        separator = _s\n                        break\n                    if re.search(_separator, text):\n                        separator = _s\n                        new_separators = separators[i + 1:]\n                        break\n\n                _separator = separator if self._is_separator_regex else re.escape(separator)\n                splits = self._split_text_with_regex_from_end(text, _separator, self._keep_separator)\n\n                # Now go merging things, recursively splitting longer texts.\n                _good_splits = []\n                _separator = \"\" if self._keep_separator else separator\n                for s in splits:\n                    if self._length_function(s) < self._chunk_size:\n                        _good_splits.append(s)\n                    else:\n                        if _good_splits:\n                            merged_text = self._merge_splits(_good_splits, _separator)\n                            final_chunks.extend(merged_text)\n                            _good_splits = []\n                        if not new_separators:\n                            final_chunks.append(s)\n                        else:\n                            other_info = self._split_text(s, new_separators)\n                            final_chunks.extend(other_info)\n                if _good_splits:\n                    merged_text = self._merge_splits(_good_splits, _separator)\n                    final_chunks.extend(merged_text)\n                return [re.sub(\"\\n{2,}\", \"\\n\", chunk.strip()) for chunk in final_chunks if chunk.strip()!=\"\"]\n\n        #\n\n        class TableCategory(Enum):\n            TOTAL = 1\n\n\n        class WordLoaderSplitterManager:\n            def __init__(self,\n                         table_config: TableConfig = None,\n                         chunk_size: int = 500,\n                         chunk_overlap: int = 50,\n                         separators: Optional[List[str]] = None,\n                         keep_separator: bool = True,\n                         is_separator_regex: bool = True,\n                         is_notfill: bool=False,\n                         is_ocr: bool=False\n                         ) -> None:\n                super().__init__()\n                self._separators = separators or [\n                    \"\\n\\n\",\n                    \"\\n\",\n                    \"。|！|？\",\n                    r\"\\.\\s|\\!\\s|\\?\\s\",\n                    r\"；|;\\s\",\n                    r\"，|,\\s\"\n                ]\n\n                self.table_config = table_config\n                self._is_separator_regex = is_separator_regex\n                # 待切分处理的\n                self.long_content = \"\"\n                #默认弄这种：下文与({self.file_name}#{heading_text})有关\n                self.notfill=is_notfill\n                self.is_ocr=is_ocr\n                #word文档\n                self.doc=None\n                # 切片数组\n                self.chunk_list: [Chunk] = []\n                self.chunk_text_list: [str] = []\n                # 标题\n                self.headings = {}  # {\"Heading_1\": \"\"}\n                self.chunk_size = chunk_size\n                self.chunk_overlap = chunk_overlap\n                # 默认使用表格前的一段文字作为整个表格的标题\n                self.ex_text = \"\"\n                self.ocr = RapidOCR()\n                self.file_name = \"\"\n                self.file_path = \"\"\n\n            # 标题-目录\n            def _get_headings_list(self):\n                return self.headings.values() if self.headings else None\n            #\n            def handle_page_ocr_result(self,ocr_result: []):\n                if ocr_result is None or len(ocr_result) == 0:\n                    return\n\n                ocr_text = \"\"\n                new_line = \"\"\n\n                ex_box = None\n\n                for i, block in enumerate(ocr_result):\n                    if len(block) != 3:\n                        continue\n                    box = block[0]\n                    txt = block[1]\n                    conf = block[2]\n\n                    # x00, y00 ----- x01, y01\n                    #          |    |\n                    # x10, y10 ----- x11, y11\n                    x00, y00 = box[0]\n                    x01, y01 = box[1]\n                    x11, y11 = box[2]\n                    x10, y10 = box[3]\n                    txt = self.data_pre_process(txt)\n                    if len(txt.strip()) == 0:\n                        continue\n\n                    if ex_box is None:\n                        ex_box = box\n                        new_line = txt\n                        # 判断是否是同一行\n                    elif ex_box[3][1] > y00:\n                        new_line = f\"{new_line} {txt}\"\n                    else:\n                        ocr_text = f\"{ocr_text}\\n{new_line}\"\n                        new_line = txt\n                        ex_box = box\n\n                    new_line = self.data_cleaning(new_line)\n\n                ocr_text = f\"{ocr_text}\\n{new_line}\"\n                return ocr_text\n\n            def data_pre_process(self,text: str):\n                if len(text) == 0:\n                    return None\n                return self.data_cleaning(text)\n\n\n            def data_cleaning(self,text: str):\n                cleaned_text = self.clean_except_value(text)\n                cleaned_text = self.clean_page_number(cleaned_text)\n                return cleaned_text\n\n            def clean_except_value(self,text: str):\n                cleaned_text = text\n                # 固定的异常字符\n                exception_txt_list = [\"il\"]\n\n                for except_txt in exception_txt_list:\n                    cleaned_text = text.replace(except_txt, \"\")\n\n                return cleaned_text\n            # 清洗页码\n            def clean_page_number(self,text: str):\n                pattern = r'^\\s*一\\s*\\d+\\s*一$'\n                if bool(re.match(pattern, text)):\n                    cleaned_text = re.sub(pattern, '', text, flags=re.IGNORECASE)\n                    return cleaned_text\n                return text\n            #\n            \n            # 判断是否是标题\n            def _is_title(self,text, font_size = None, bold = None, separators: [] = None):\n                keywords = [\"\"]\n\n                # 长度\n                if len(text) == 0 or len(text) > 20:\n                    return False\n\n                for element in separators:\n                    if element in text:\n                        return False\n                    #\n                #    \n                # 字体大小\n                if font_size and font_size > 12:\n                    return True\n\n                # 加粗\n                if bold:\n                    return True\n\n                # 大写\n                if text.isupper() or text.istitle():\n                    return True\n\n                # 特定关键词\n                for keyword in keywords:\n                    if keyword in text:\n                        return True\n\n                return False\n            #endif\n            \n            def get_parent_childrens(self,smallchunks):\n                cont = []\n                pos = []\n                for p in self.doc.paragraphs:\n                    #print(p.style.name)\n                    #print(p.text)\n                    style_name = p.style.name\n                    if style_name.startswith('Heading'):\n                        #print(style_name,p.text,sep=':')\n                        pos.append(int(style_name[-1]))\n                        cont.append(p.text)\n                    #\n                #endfor\n                # construct keys\n                # input=[1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3]\n                # output = ['1', '1-1', '1-2', '2', '2-1', '2-2', '2-3', '3', '3-1', '3-2', '3-2-1', '3-2-2']\n                keys = ['0'] * len(pos)\n                def dfs(p, f):\n                    x = 1\n                    if keys[p] == '0':\n                        keys[p] = f + '-' + str(x)\n                    x += 1\n                    th = keys[p]\n                    for i in range(p+1, len(pos)):\n                        if pos[i] - 1 == pos[p]:\n                            #print(i)\n                            dfs(i, th +'-')\n                        elif pos[i] == pos[p]:\n                            if keys[i] == '0':\n                                keys[i] = f + '-' + str(x)\n                                x += 1\n                                th = keys[i]\n                        elif pos[i] + 1 == pos[p]:\n                            return\n                dfs(0, '')\n                \n                keys = [e.strip('-').replace('--', '-') for e in keys]\n                headers=[]\n                for i in range(len(keys)):\n                    headers.append({'pid':'None','next':None,'myid':str(uuid.uuid1()),'id':keys[i],'value':cont[i],'children':[]})\n                #\n                #id,pid,value,brothervalue\n                headerlist=[]\n                for i in range(0,len(headers)-1):\n                    for j in range(i+1,len(headers)):\n                        if(headers[j]['id'].find(headers[i]['id'])==0 and headers[j]['id'].replace(headers[i]['id'],'').count('-')==1):\n                            headers[j]['pid']=headers[i]['myid']\n                            headers[j]['value']=headers[i]['value']+'-'+headers[j]['value']\n                            #如果有下一个同级别的，就记录这个value\n                            if j<len(headers)-1:\n                                index1=headers[j+1]['id'].rfind('-')\n                                index2=headers[j]['id'].rfind('-')\n                                if((index1==index2) and (headers[j+1]['id'][0:index1]==headers[j]['id'][0:index1])):\n                                    headers[j]['next']=headers[j+1]['value']\n                                #endif\n                            #endif\n                            headers[i]['children'].append(headers[j])\n                        #\n                #\n                #print(headers)\n                def getItemByID(id):\n                    for i in range(0,len(headers)):\n                        if(headers[i]['id']==id):\n                            return headers[i]\n                        #nedif\n                    #endfor\n                    return None\n                #enddef\n                #如果pid是None代表是一级目录，nextvalue就是它的下一个同级目录\n                for i in range(0,len(headers)):\n                    if(headers[i]['pid']=='None'):\n                        nextid=str(int(headers[i]['id'])+1)\n                        nextItem=getItemByID(nextid)\n                        if(nextItem!=None):\n                            headers[i]['next']=nextItem['value']\n                        #endif\n                    #nedif\n                #endfor\n                #遍历每个节点，如果有children就设置children中的nextvalue，比如1-1的nextvalue是1-2,\n                #如果没有下一个兄弟节点，next就设置为父节点的nextvalue\n                for i in range(0,len(headers)):\n                    childcount=len(headers[i]['children'])\n                    if childcount>0:\n                        if(childcount==1):\n                            headers[i]['children'][0]['next']=headers[i]['next']\n                        else:\n                            for j in range(0,childcount-1):\n                                headers[i]['children'][j]['next']=headers[i]['children'][j+1]['value']\n                            #\n                            headers[i]['children'][childcount-1]['next']=headers[i]['next']\n                        #endif\n                    #endif\n                #endfor\n                parents=headers\n                alldocs=[]\n                allids=[]\n                alltxts=[]\n                for item2 in parents:\n                    myvalue=item2['value']\n                    myid=item2['myid']\n                    contentall=myvalue+'\\n\\n'\n                    for child in smallchunks:\n                        mycontent=child.page_content.split('`')\n                        childrenid=child.metadata['myid']\n                        if len(mycontent)<2:\n                            if(mycontent[0].find(myvalue)>=0):\n                                print('没识别出段落')\n                                contentall=contentall+mycontent[0]\n                                if(childrenid not in allids):\n                                    allids.append(childrenid)\n                                else:\n                                    alldocs = [item for item in alldocs if item['myid']!=childrenid]\n                                #endif\n                                alldocs.append({'myid':childrenid,'pid':myid,'content':mycontent[0],'is_parent':'-1'})\n                            #endif\n                        else:\n                            if(mycontent[0].find(myvalue)>=0):\n                                if(mycontent[0]!=myvalue):\n                                    contentall=contentall+mycontent[0][mycontent[0].rfind('-')+1:]+mycontent[1]\n                                else:\n                                    contentall=contentall+mycontent[1]\n                                #endif\n                                if(childrenid not in allids):\n                                    allids.append(childrenid)\n                                else:\n                                    alldocs = [item for item in alldocs if item['myid']!=childrenid]\n                                #\n                                alldocs.append({'myid':childrenid,'pid':myid,'content':child.page_content.replace('`','\\n\\n'),'is_parent':'0','source':self.file_path,'title':mycontent[0]})\n                            #endif\n                        #endif\n                    #endfor\n                    if len(contentall)>len(myvalue+'\\n\\n'):\n                        if(contentall.replace('-','').replace('\\n','') not in alltxts):\n                            alltxts.append(contentall.replace('-','').replace('\\n',''))\n                            alldocs.append({'myid':myid,'pid':item2['pid'],'content':contentall,'is_parent':'1','source':self.file_path,'title':myvalue})\n                        #endif\n                    #endif\n                #endfor\n                #存在文档封面等chunk，这种不存在任何父节点，需要单独处理\n                for child in smallchunks:\n                    if(child.metadata['myid'] not in allids):\n                        alldocs.insert(0,{'myid':child.metadata['myid'],'pid':'None','content':child.page_content,'is_parent':'0','source':self.file_path,'title':''})\n                    #\n                #endif\n                #big为1是合成后的，0是最小的分片，如果0和1的content完全一样，就删除big是0的\n                redundancytxts=[]\n                for i in range(len(alldocs)-1, -1, -1):\n                    tmpcontent=alldocs[i]['content'].replace('-','').replace('\\n','')\n                    if tmpcontent in alltxts and alldocs[i]['is_parent']=='0':\n                        del alldocs[i]\n                        redundancytxts.append(tmpcontent)\n                        #print('删除:'+str(i))\n                    #endif\n                #endfor\n                #父节点变is_parent变0\n                for i in range(len(alldocs)-1, -1, -1):\n                    tmpcontent=alldocs[i]['content'].replace('-','').replace('\\n','')\n                    if tmpcontent in redundancytxts and alldocs[i]['is_parent']=='1':\n                        alldocs[i]['is_parent']='0'\n                    #endif\n                #endfor\n                return alldocs\n            #\n            \n            def _get_chunk_title(self):\n                if self.headings:\n                    heading_text = \"-\".join(filter(None, self.headings.values()))\n                    if heading_text and len(heading_text) > 1:\n                        if(self.notfill):\n                            return f\"{heading_text}`\"\n                        else:\n                            return f\"下文与({self.file_name}#{heading_text})有关。\"\n                        #\n                    #\n                return \"\"\n\n            def _update_heading_dict(self, heading_name: str, heading_content: str):\n                if \"Heading\" in heading_name:\n                    num = int(heading_name.split('Heading ')[1])\n                else:\n                    # 如果是非正规word，暂时一律以一级标题处理\n                    num = 1\n\n                for key in list(self.headings):\n                    if int(key.split('Heading_')[1]) >= num:\n                        del self.headings[key]\n                heading_key = f\"Heading_{num}\"\n                self.headings[heading_key] = heading_content\n\n            def _split_text_to_chunks(self, text: str):\n\n                prefix = self._get_chunk_title()\n\n                # 预留出chunk标题的长度\n                chunk_content_size = self.chunk_size - len(prefix)\n                if chunk_content_size < 20:\n                    chunk_content_size = 20\n                #endif\n\n                if len(text) < chunk_content_size:\n                   \n                    chunk_text = f\"{prefix}{text}\"\n                    chunk = Chunk(content=chunk_text, count=1, index=1)\n                    self.chunk_text_list.append(chunk_text)\n                    return [chunk]\n                #\n\n                text_splitter = ChineseRecursiveTextSplitter(\n                    keep_separator=True,\n                    is_separator_regex=True,\n                    chunk_size=chunk_content_size,\n                    chunk_overlap=self.chunk_overlap\n                )\n\n                chunks = text_splitter.split_text(text.strip())\n\n                chunks_length = len(chunks)\n\n                result_chunks = []\n                for i, content in enumerate(chunks):\n                    chunk_text = f\"{prefix}{content}\"\n                    chunk = Chunk(content=chunk_text, count=chunks_length, index=i)\n\n                    self.chunk_text_list.append(chunk_text)\n                    result_chunks.append(chunk)\n                return result_chunks\n\n                # return [f\"{prefix}{chunk}\" for chunk in chunks if chunk]\n\n            def _process_paragraph_text(self, paragraph, paragraph_text):\n                paragraph_style_name = paragraph.style.name\n                # paragraph_text = paragraph.text\n                paragraph_text = paragraph_text\n\n                # 既是标题也是内容时，则当正文处理\n                if not paragraph_style_name.startswith(\"Heading \") or not self._is_title(paragraph_text, separators=[\"：\"]):\n                    # 不是标题，则都是正文\n                    self.long_content = f\"{self.long_content}\\n{paragraph_text}\"\n                    return\n\n                # 正文部分处理流程\n                # 遇到新标题时，需将前面累积的文本处理切片\n                # 更新标题\n                if not self.long_content:\n                    self._update_heading_dict(paragraph_style_name, paragraph_text)\n                    return\n\n                chunks = self._split_text_to_chunks(self.long_content)\n                self.chunk_list.extend(chunks)\n\n                # 置空\n                self.long_content = \"\"\n                self._update_heading_dict(paragraph_style_name, paragraph_text)\n\n            def _get_paragraph_text(self, paragraph):\n                # 一个文本段落中只有text和image，没有table\n                paragraph_content = \"\"\n                for run in paragraph.runs:\n                    # 图片\n                    blips = run.element.xpath('.//a:blip')\n                    if blips:\n                        if(self.is_ocr==False):\n                            continue\n                        #endif\n                        for blip in blips:\n                            try:\n\n                                rId = blip.embed\n                                image_part = run.part.related_parts[rId]\n                                image = Image.open(BytesIO(image_part.blob))\n                                filetype='.png'\n                                if(image.format!='PNG'):\n                                    filetype='.jpg'\n                                #\n                                myurl='images/'+str(uuid.uuid1())+filetype\n                                image.save(myurl)\n                                result, _ = self.ocr(image_part.blob)\n                                image_content = self.handle_page_ocr_result(result)\n                                if(image_content==None):\n                                    image_content=''\n                                #endif\n                                # image_content = f\"<image_content/>{image_content}</image_content>\"\n                                paragraph_content = f\"{paragraph_content}\\n![]({myurl}){image_content}\"\n\n                                # global chunk_content\n                                # chunk_content = f\"{chunk_content}\\n{paragraph_content}\"\n                            except Exception as e:\n                                print(f\"{e}\")\n                    # 文字\n                    elif run.element.text:\n                        paragraph_content = f\"{paragraph_content}{run.text}\"\n                    else:\n                        print(run)\n                if paragraph_content:\n                    self._process_paragraph_text(paragraph, paragraph_content)\n                    self.ex_text = paragraph_content\n\n            # 表格\n            def _get_table_text(self, table):\n                table_content = \"\"\n                for row in table.rows:\n                    for cell in row.cells:\n                        for paragraph in cell.paragraphs:\n                            table_content += paragraph.text.strip() + \"\\n\"\n                return table_content\n\n            def _split_table_to_chunks(self, table):\n                # self.table_config.chunk_title_format.format(title=\"\")\n                #print(self.headings.values())\n                heading_text = \"-\".join(filter(None, self.headings.values()))\n\n                chunk_title = \"\"\n                if heading_text and len(heading_text) > 1:\n                    if(self.notfill):\n                        chunk_title= f\"{heading_text}`\"\n                    else:\n                        chunk_title = f\"下文与({self.file_name}#{heading_text})有关。\"\n                    #\n                #\n\n                if self.ex_text and len(self.ex_text) < 20 and len(self.ex_text) > 1:\n                    if(self.notfill):\n                        chunk_title= f\"{heading_text}`\"\n                    else:\n                        chunk_title = f\"下文与({self.file_name}#{heading_text}#{self.ex_text})有关。\"\n                    #\n                #\n                table_chunks = []\n                title_list = []\n                table_row_length = len(table.rows) - 1\n                for i, row in enumerate(table.rows):\n                    row_content = \"\"\n                    if i == 0:\n                        for cell in row.cells:\n                            cell_content = \",\".join([paragraph.text.strip() for paragraph in cell.paragraphs if paragraph.text])\n                            # if cell_content:\n                            #     title_list.append(cell_content)\n                            title_list.append(cell_content)\n                            continue\n                        continue\n\n                    for cell_index, cell in enumerate(row.cells):\n                        cell_content = \"、\".join([paragraph.text.strip() for paragraph in cell.paragraphs if paragraph.text])\n                        if cell_content:\n                            cell_content = title_list[cell_index] + \":\" + cell_content + \";\"\n                            row_content = f\"{row_content}{cell_content}\"\n                    if row_content:\n                        row_chunk = f\"{chunk_title}\\n\\n{row_content}\"\n                        self.chunk_text_list.append(row_chunk)\n                        chunk = Chunk(content=row_chunk, count=table_row_length, index=i)\n                        table_chunks.append(chunk)\n\n                return table_chunks\n            #\n            \n            def convert_chunks(self,smallchunks):\n                items=[]\n                for child in smallchunks:\n                    if(child.page_content.find('下文与(')>=0 and child.page_content.find(')有关')>=0):\n                        title=child.page_content[child.page_content.find('下文与(')+4:child.page_content.find(')有关')]\n                        mytitle=title[title.find('#')+1:]\n                        items.append({'myid':child.metadata['myid'],'pid':'None','content':child.page_content,'is_parent':'0','source':child.metadata['source'],'title':mytitle})\n                    else:\n                        items.append({'myid':child.metadata['myid'],'pid':'None','content':child.page_content,'is_parent':'0','source':child.metadata['source'],'title':''})\n                    #endif\n                #\n                return items\n            #enddef\n            \n            def get_all_text(self,smallchunks):\n                txts=[]\n                for child in smallchunks:\n                    if(child.page_content.find('`')<0):\n                        txts.append(child.page_content)\n                    else:\n                        mycontent=child.page_content.split('`')\n                        title=mycontent[0]\n                        mytitle=title[title.rfind('-')+1:]\n                        txts.append(mytitle+'\\n'+mycontent[1])\n                    #endif\n                #\n                item={'myid':str(uuid.uuid1()),'pid':'None','content':'\\n'.join(txts),'is_parent':'0','source':self.file_path,'title':self.file_name}\n                return item\n            #enddef\n            \n            def load_and_split_file(self,file_path: str):\n                if(file_path.find('/')>=0):\n                    self.file_name = file_path.split(\"/\")[-1]\n                else:\n                    self.file_name = file_path.split(\"\\\\\")[-1]\n                #endif\n                self.file_name = os.path.splitext(self.file_name)[0]\n                self.file_path=file_path\n                from docx import Document as docx_Document\n                doc = docx_Document(file_path)\n                self.doc=doc\n\n                for element in doc.element.body:\n                    if isinstance(element, CT_P):\n                        paragraph = Paragraph(element, doc)\n                        self._get_paragraph_text(paragraph)\n                    elif isinstance(element, CT_Tbl):\n                        # 遇到表格时，处理掉上文\n                        chunks = self._split_text_to_chunks(self.long_content)\n                        self.chunk_list.extend(chunks)\n                       \n\n                        self.long_content = \"\"\n\n                        table = Table(element, doc)\n                        chunks = self._split_table_to_chunks(table)\n                        self.chunk_list.extend(chunks)\n\n                    elif isinstance(element, CT_Inline):\n                        print(f\"element:{element}\")\n                    else:\n                        print(f\"element-else:{element}\")\n\n                # 收尾\n                \n                if self.long_content:\n                    chunks = self._split_text_to_chunks(self.long_content)\n                    self.chunk_list.extend(chunks)\n                #\n                from langchain.docstore.document import Document\n                return [Document(page_content=chunk.content, metadata={\"source\": self.file_path,\"myid\":str(uuid.uuid1())}) for chunk in self.chunk_list]\n            #enddef\n        #enddef\n        current_path = Path().resolve()\n        #print(current_path)\n        myseparators = self.separators.split(',')\n        #print(myseparators)\n        a=self.path\n        #print(a)\n        document_url=self.resolve_path(self.path)\n        if(a.find('http:')>=0 or a.find('https:')>=0):\n            urltmp=a[a.find('http:'):].replace('\\\\','/').replace('http:/','http://')\n            if a.find('https:')>=0:\n                urltmp=a[a.find('https:'):].replace('\\\\','/').replace('https:/','https://')\n            #\n            print(urltmp)\n            document_url=urltmp\n            self.path=self.download_file(urltmp)\n        #endif\n        print(self.path)\n        if not self.path:\n            raise ValueError(\"Please, upload a file to use this component.\")\n        resolved_path = self.resolve_path(self.path)\n        silent_errors = self.silent_errors\n\n        extension = Path(resolved_path).suffix[1:].lower()\n        filepath =resolved_path\n        if extension == \"doc\":\n            tmp_dir = 'tmpfiles'\n            os.makedirs(tmp_dir, exist_ok=True)\n            filepath = os.path.join(tmp_dir,os.path.basename(resolved_path).replace('.doc','.docx'))\n            #doc转docx\n            subprocess.call([\"soffice\",\"--headless\",\"--convert-to\",\"docx\",\"--outdir\",tmp_dir,resolved_path])\n        #end\n        #解析word\n        table_config = TableConfig()\n        #三种切片方式\n        if(self.split_strategy=='默认切分'):\n            manager = WordLoaderSplitterManager(table_config=table_config,is_ocr=self.is_ocr)\n            smallchunks = manager.load_and_split_file(file_path=filepath)\n            items=manager.convert_chunks(smallchunks)\n        elif(self.split_strategy=='自定义切片'):\n            manager = WordLoaderSplitterManager(table_config=table_config,chunk_size=self.chunk_size,chunk_overlap=self.chunk_overlap,separators=myseparators,is_ocr=self.is_ocr)\n            smallchunks = manager.load_and_split_file(file_path=filepath)\n            items=manager.convert_chunks(smallchunks)\n        elif(self.split_strategy=='整文件切片'):\n            manager = WordLoaderSplitterManager(table_config=table_config,chunk_size=15000,is_notfill=True,is_ocr=self.is_ocr)\n            smallchunks = manager.load_and_split_file(file_path=filepath)\n            items=[manager.get_all_text(smallchunks)]\n        else:\n            manager = WordLoaderSplitterManager(table_config=table_config,is_ocr=self.is_ocr)\n            smallchunks = manager.load_and_split_file(file_path=filepath)\n            items=manager.convert_chunks(smallchunks)\n        #endif\n        #print(items)\n        datas=[]\n        for item in items:\n            mytext = item.pop('content')\n            item['document_id']=self.document_id\n            item['source']=document_url\n            datas.append(Data(text=mytext,data=item))\n        #endfor\n        self.status = datas\n        os.remove(self.path)\n        return datas\n    #\n#\n",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "path": {
                "info": "Supported file types: docx, doc",
                "list": false,
                "name": "path",
                "show": true,
                "type": "file",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": true,
                "fileTypes": [
                  "docx",
                  "doc"
                ],
                "file_path": "03736035-08a6-472e-bc3b-574b04fe9f75/紫光云报销制度.docx",
                "title_case": false,
                "placeholder": "",
                "display_name": "Path",
                "load_from_db": false,
                "trace_as_metadata": true
              },
              "_type": "Component",
              "is_ocr": {
                "info": "",
                "list": false,
                "name": "is_ocr",
                "show": true,
                "type": "bool",
                "value": true,
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "光学字符识别",
                "trace_as_metadata": true
              },
              "chunk_size": {
                "info": "",
                "list": false,
                "name": "chunk_size",
                "show": true,
                "type": "int",
                "value": 500,
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "切片最大长度",
                "trace_as_metadata": true
              },
              "separators": {
                "info": "The character to split on. Defaults to newline.",
                "list": false,
                "name": "separators",
                "show": true,
                "type": "str",
                "value": "\\n\\n,\\n,。|！|？",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "separators",
                "load_from_db": false,
                "trace_as_metadata": true
              },
              "document_id": {
                "info": "",
                "list": false,
                "name": "document_id",
                "show": true,
                "type": "str",
                "value": "None",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "文档ID",
                "load_from_db": false,
                "trace_as_metadata": true
              },
              "chunk_overlap": {
                "info": "",
                "list": false,
                "name": "chunk_overlap",
                "show": true,
                "type": "int",
                "value": 50,
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "切片重叠最大字数",
                "trace_as_metadata": true
              },
              "silent_errors": {
                "info": "If true, errors will not raise an exception.",
                "list": false,
                "name": "silent_errors",
                "show": true,
                "type": "bool",
                "value": false,
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "Silent Errors",
                "trace_as_metadata": true
              },
              "split_strategy": {
                "info": "",
                "name": "split_strategy",
                "show": true,
                "type": "str",
                "value": "整文件切片",
                "dynamic": false,
                "options": [
                  "默认切分",
                  "自定义切片",
                  "整文件切片"
                ],
                "advanced": false,
                "required": true,
                "title_case": false,
                "placeholder": "",
                "display_name": "切片策略",
                "load_from_db": false,
                "trace_as_metadata": true
              }
            },
            "description": "A word file loader.",
            "field_order": [
              "document_id",
              "path",
              "is_ocr",
              "split_strategy",
              "chunk_size",
              "chunk_overlap",
              "separators",
              "silent_errors"
            ],
            "base_classes": [
              "Data"
            ],
            "display_name": "WordFile",
            "output_types": [],
            "custom_fields": {},
            "documentation": "",
            "conditional_paths": []
          },
          "type": "WordFile",
          "description": "A word file loader.",
          "display_name": "WordFile"
        },
        "type": "genericNode",
        "width": 384,
        "height": 807,
        "dragging": false,
        "position": {
          "x": -2104.0398530855036,
          "y": 1176.7551145438565
        },
        "selected": false,
        "positionAbsolute": {
          "x": -2104.0398530855036,
          "y": 1176.7551145438565
        }
      },
      {
        "id": "UniChatOutput-hi43z",
        "data": {
          "id": "UniChatOutput-hi43z",
          "node": {
            "beta": false,
            "icon": "/zy-icons/UniChatOutputComponent.png",
            "edited": false,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "message",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "method": "message_response",
                "selected": "Message",
                "display_name": "消息"
              }
            ],
            "template": {
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "# -*- coding: utf-8 -*-\nfrom axiestudio.base.io.chat import ChatComponent\nfrom axiestudio.inputs import BoolInput\nfrom axiestudio.io import DropdownInput, MessageTextInput, Output\nfrom axiestudio.memory import store_message\nfrom axiestudio.schema.message import Message\nfrom axiestudio.utils.MinioUtils import MinioUtils\n\nclass UniChatOutput(ChatComponent):\n    display_name = \"对话输出\"\n    description = \"在调试窗口中显示一条聊天消息。\"\n    icon = \"ChatOutput\"\n    name = \"UniChatOutput\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"文本\",\n            info=\"要输出的消息。\",\n        ),\n        BoolInput(\n            name=\"store_message\",\n            display_name=\"存储消息\",\n            info=\"将消息存储到历史记录。\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"发送者\",\n            options=[\"Machine\", \"User\"],\n            value=\"Machine\",\n            advanced=True,\n            info=\"发送者。\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\", display_name=\"发送者名称\", info=\"发送者的名称。\", value=\"AI\", advanced=True\n        ),\n        MessageTextInput(\n            name=\"session_id\", display_name=\"会话ID\", info=\"消息的会话ID。\", advanced=False\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"数据模版\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"将数据转化为文本的模版。如果为空，模版会被动态地设置为数据的文本密匙。\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"消息\", name=\"message\", method=\"message_response\"),\n    ]\n    def __init__(self, **kwargs):\n        # 调用父类的初始化方法\n        super().__init__(**kwargs)\n        self.icon= MinioUtils().get_full_path('zy-icons', 'UniChatOutputComponent.png')\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n        )\n        if self.session_id and isinstance(message, Message) and isinstance(message.text, str):\n            store_message(\n                message,\n                flow_id=self.graph.flow_id,\n            )\n            self.message.value = message\n\n        self.status = message\n        return message\n",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "_type": "Component",
              "sender": {
                "info": "发送者。",
                "name": "sender",
                "show": true,
                "type": "str",
                "value": "Machine",
                "dynamic": false,
                "options": [
                  "Machine",
                  "User"
                ],
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "发送者",
                "trace_as_metadata": true
              },
              "session_id": {
                "info": "消息的会话ID。",
                "list": false,
                "name": "session_id",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "会话ID",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "input_value": {
                "info": "要输出的消息。",
                "list": false,
                "name": "input_value",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "文本",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "sender_name": {
                "info": "发送者的名称。",
                "list": false,
                "name": "sender_name",
                "show": true,
                "type": "str",
                "value": "AI",
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "发送者名称",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "data_template": {
                "info": "将数据转化为文本的模版。如果为空，模版会被动态地设置为数据的文本密匙。",
                "list": false,
                "name": "data_template",
                "show": true,
                "type": "str",
                "value": "{text}",
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "数据模版",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "store_message": {
                "info": "将消息存储到历史记录。",
                "list": false,
                "name": "store_message",
                "show": true,
                "type": "bool",
                "value": true,
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "存储消息",
                "trace_as_metadata": true
              }
            },
            "description": "在调试窗口中显示一条聊天消息。",
            "field_order": [
              "input_value",
              "store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template"
            ],
            "base_classes": [
              "Message"
            ],
            "display_name": "对话输出",
            "output_types": [],
            "custom_fields": {},
            "documentation": "",
            "conditional_paths": []
          },
          "type": "UniChatOutput"
        },
        "type": "genericNode",
        "width": 384,
        "height": 403,
        "position": {
          "x": 541.1268216119704,
          "y": 1584.4953264560463
        },
        "selected": false
      },
      {
        "id": "UniChatInput-ViEcc",
        "data": {
          "id": "UniChatInput-ViEcc",
          "node": {
            "beta": false,
            "icon": "/zy-icons/UniChatInputComponent.png",
            "edited": false,
            "frozen": false,
            "pinned": false,
            "outputs": [
              {
                "name": "message",
                "cache": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__",
                "method": "message_response",
                "selected": "Message",
                "display_name": "消息"
              }
            ],
            "template": {
              "code": {
                "info": "",
                "list": false,
                "name": "code",
                "show": true,
                "type": "code",
                "value": "# -*- coding: utf-8 -*-\nfrom axiestudio.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom axiestudio.base.io.chat import ChatComponent\nfrom axiestudio.inputs import BoolInput\nfrom axiestudio.io import DropdownInput, FileInput, MessageTextInput, MultilineInput, Output\nfrom axiestudio.memory import store_message\nfrom axiestudio.schema.message import Message\nfrom axiestudio.utils.MinioUtils import MinioUtils\n\nclass UniChatInput(ChatComponent):\n    display_name = \"对话输入\"\n    description = \"从调试窗口获得对话内容\"\n    icon = \"ChatInput\"\n    name = \"UniChatInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"文本\",\n            value=\"\",\n            info=\"要输入的消息。\",\n        ),\n        BoolInput(\n            name=\"store_message\",\n            display_name=\"存储消息\",\n            info=\"将消息存储到历史记录。\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"发送者类型\",\n            options=[\"Machine\", \"User\"],\n            value=\"User\",\n            info=\"发送者的类型。\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"发送者名称\",\n            info=\"发送者的名称。\",\n            value=\"User\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\", display_name=\"会话ID\", info=\"会话ID\", advanced=False\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"文件\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"与消息一同发送的文件。\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"消息\", name=\"message\", method=\"message_response\"),\n    ]\n    def __init__(self, **kwargs):\n        # 调用父类的初始化方法\n        super().__init__(**kwargs)\n        self.icon= MinioUtils().get_full_path('zy-icons', 'UniChatInputComponent.png')\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n        )\n\n        if self.session_id and isinstance(message, Message) and isinstance(message.text, str):\n            store_message(\n                message,\n                flow_id=self.graph.flow_id,\n            )\n            self.message.value = message\n\n        self.status = message\n        return message\n",
                "dynamic": true,
                "advanced": true,
                "password": false,
                "required": true,
                "fileTypes": [],
                "file_path": "",
                "multiline": true,
                "title_case": false,
                "placeholder": "",
                "load_from_db": false
              },
              "_type": "Component",
              "files": {
                "info": "与消息一同发送的文件。",
                "list": true,
                "name": "files",
                "show": true,
                "type": "file",
                "value": "",
                "dynamic": false,
                "advanced": true,
                "required": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "title_case": false,
                "placeholder": "",
                "display_name": "文件",
                "trace_as_metadata": true
              },
              "sender": {
                "info": "发送者的类型。",
                "name": "sender",
                "show": true,
                "type": "str",
                "value": "User",
                "dynamic": false,
                "options": [
                  "Machine",
                  "User"
                ],
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "发送者类型",
                "trace_as_metadata": true
              },
              "session_id": {
                "info": "会话ID",
                "list": false,
                "name": "session_id",
                "show": true,
                "type": "str",
                "value": "",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "会话ID",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "input_value": {
                "info": "要输入的消息。",
                "list": false,
                "name": "input_value",
                "show": true,
                "type": "str",
                "value": "请帮我审核一下报销单:http://gis.unicloud.com:8086/test/danju.xlsx",
                "dynamic": false,
                "advanced": false,
                "required": false,
                "multiline": true,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "文本",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "sender_name": {
                "info": "发送者的名称。",
                "list": false,
                "name": "sender_name",
                "show": true,
                "type": "str",
                "value": "User",
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "input_types": [
                  "Message"
                ],
                "placeholder": "",
                "display_name": "发送者名称",
                "load_from_db": false,
                "trace_as_input": true,
                "trace_as_metadata": true
              },
              "store_message": {
                "info": "将消息存储到历史记录。",
                "list": false,
                "name": "store_message",
                "show": true,
                "type": "bool",
                "value": true,
                "dynamic": false,
                "advanced": true,
                "required": false,
                "title_case": false,
                "placeholder": "",
                "display_name": "存储消息",
                "trace_as_metadata": true
              }
            },
            "description": "从调试窗口获得对话内容",
            "field_order": [
              "input_value",
              "store_message",
              "sender",
              "sender_name",
              "session_id",
              "files"
            ],
            "base_classes": [
              "Message"
            ],
            "display_name": "对话输入",
            "output_types": [],
            "custom_fields": {},
            "documentation": "",
            "conditional_paths": []
          },
          "type": "UniChatInput"
        },
        "type": "genericNode",
        "width": 384,
        "height": 403,
        "dragging": false,
        "position": {
          "x": -2011.5235258825771,
          "y": 583.1414648266773
        },
        "selected": true,
        "positionAbsolute": {
          "x": -2011.5235258825771,
          "y": 583.1414648266773
        }
      }
    ],
    "viewport": {
      "x": 982.8472970387796,
      "y": -210.16015321425948,
      "zoom": 0.4364091623803481
    }
  },
  "metadata": {
    "UniBaoxiaoFile": {
      "count": 1
    },
    "ParseURL": {
      "count": 1
    },
    "Prompt": {
      "count": 1
    },
    "ParseData": {
      "count": 1
    },
    "OpenAICompatibleModel": {
      "count": 1
    },
    "UniTextInput": {
      "count": 1
    },
    "WordFile": {
      "count": 1
    },
    "UniChatOutput": {
      "count": 1
    },
    "UniChatInput": {
      "count": 1
    },
    "total": 9
  },
  "original": {
    "id": "e270d8f6-85e1-4bba-8efd-6e0a7e9967dd",
    "name": "1844941705980358657",
    "description": "发票审核助手",
    "is_component": false,
    "liked_by_count": "0",
    "downloads_count": "9",
    "metadata": {
      "UniBaoxiaoFile": {
        "count": 1
      },
      "ParseURL": {
        "count": 1
      },
      "Prompt": {
        "count": 1
      },
      "ParseData": {
        "count": 1
      },
      "OpenAICompatibleModel": {
        "count": 1
      },
      "UniTextInput": {
        "count": 1
      },
      "WordFile": {
        "count": 1
      },
      "UniChatOutput": {
        "count": 1
      },
      "UniChatInput": {
        "count": 1
      },
      "total": 9
    },
    "last_tested_version": "1.0.9",
    "private": false,
    "data": {
      "edges": [
        {
          "id": "reactflow__edge-ParseURL-CLLZq{œdataTypeœ:œParseURLœ,œidœ:œParseURL-CLLZqœ,œnameœ:œurl_textœ,œoutput_typesœ:[œMessageœ]}-UniBaoxiaoFile-wTUfp{œfieldNameœ:œexcelurlœ,œidœ:œUniBaoxiaoFile-wTUfpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
          "data": {
            "sourceHandle": {
              "id": "ParseURL-CLLZq",
              "name": "url_text",
              "dataType": "ParseURL",
              "output_types": [
                "Message"
              ]
            },
            "targetHandle": {
              "id": "UniBaoxiaoFile-wTUfp",
              "type": "str",
              "fieldName": "excelurl",
              "inputTypes": [
                "Message"
              ]
            }
          },
          "source": "ParseURL-CLLZq",
          "target": "UniBaoxiaoFile-wTUfp",
          "className": "",
          "sourceHandle": "{œdataTypeœ:œParseURLœ,œidœ:œParseURL-CLLZqœ,œnameœ:œurl_textœ,œoutput_typesœ:[œMessageœ]}",
          "targetHandle": "{œfieldNameœ:œexcelurlœ,œidœ:œUniBaoxiaoFile-wTUfpœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
        },
        {
          "id": "reactflow__edge-ParseData-ocaSN{œdataTypeœ:œParseDataœ,œidœ:œParseData-ocaSNœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-Prompt-NYSg3{œfieldNameœ:œcontextœ,œidœ:œPrompt-NYSg3œ,œinputTypesœ:[œMessageœ,œTextœ],œtypeœ:œstrœ}",
          "data": {
            "sourceHandle": {
              "id": "ParseData-ocaSN",
              "name": "text",
              "dataType": "ParseData",
              "output_types": [
                "Message"
              ]
            },
            "targetHandle": {
              "id": "Prompt-NYSg3",
              "type": "str",
              "fieldName": "context",
              "inputTypes": [
                "Message",
                "Text"
              ]
            }
          },
          "source": "ParseData-ocaSN",
          "target": "Prompt-NYSg3",
          "className": "",
          "sourceHandle": "{œdataTypeœ:œParseDataœ,œidœ:œParseData-ocaSNœ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
          "targetHandle": "{œfieldNameœ:œcontextœ,œidœ:œPrompt-NYSg3œ,œinputTypesœ:[œMessageœ,œTextœ],œtypeœ:œstrœ}"
        },
        {
          "id": "reactflow__edge-Prompt-NYSg3{œdataTypeœ:œPromptœ,œidœ:œPrompt-NYSg3œ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}-UniTextInput-LJTY8{œfieldNameœ:œinput_valueœ,œidœ:œUniTextInput-LJTY8œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
          "data": {
            "sourceHandle": {
              "id": "Prompt-NYSg3",
              "name": "prompt",
              "dataType": "Prompt",
              "output_types": [
                "Message"
              ]
            },
            "targetHandle": {
              "id": "UniTextInput-LJTY8",
              "type": "str",
              "fieldName": "input_value",
              "inputTypes": [
                "Message"
              ]
            }
          },
          "source": "Prompt-NYSg3",
          "target": "UniTextInput-LJTY8",
          "className": "",
          "sourceHandle": "{œdataTypeœ:œPromptœ,œidœ:œPrompt-NYSg3œ,œnameœ:œpromptœ,œoutput_typesœ:[œMessageœ]}",
          "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œUniTextInput-LJTY8œ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
        },
        {
          "id": "reactflow__edge-UniTextInput-LJTY8{œdataTypeœ:œUniTextInputœ,œidœ:œUniTextInput-LJTY8œ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}-OpenAICompatibleModel-cxm6H{œfieldNameœ:œinput_valueœ,œidœ:œOpenAICompatibleModel-cxm6Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
          "data": {
            "sourceHandle": {
              "id": "UniTextInput-LJTY8",
              "name": "text",
              "dataType": "UniTextInput",
              "output_types": [
                "Message"
              ]
            },
            "targetHandle": {
              "id": "OpenAICompatibleModel-cxm6H",
              "type": "str",
              "fieldName": "input_value",
              "inputTypes": [
                "Message"
              ]
            }
          },
          "source": "UniTextInput-LJTY8",
          "target": "OpenAICompatibleModel-cxm6H",
          "className": "",
          "sourceHandle": "{œdataTypeœ:œUniTextInputœ,œidœ:œUniTextInput-LJTY8œ,œnameœ:œtextœ,œoutput_typesœ:[œMessageœ]}",
          "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œOpenAICompatibleModel-cxm6Hœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
        },
        {
          "id": "reactflow__edge-WordFile-JYBuv{œdataTypeœ:œWordFileœ,œidœ:œWordFile-JYBuvœ,œnameœ:œchunksœ,œoutput_typesœ:[œDataœ]}-ParseData-ocaSN{œfieldNameœ:œdataœ,œidœ:œParseData-ocaSNœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}",
          "data": {
            "sourceHandle": {
              "id": "WordFile-JYBuv",
              "name": "chunks",
              "dataType": "WordFile",
              "output_types": [
                "Data"
              ]
            },
            "targetHandle": {
              "id": "ParseData-ocaSN",
              "type": "other",
              "fieldName": "data",
              "inputTypes": [
                "Data"
              ]
            }
          },
          "source": "WordFile-JYBuv",
          "target": "ParseData-ocaSN",
          "className": "",
          "sourceHandle": "{œdataTypeœ:œWordFileœ,œidœ:œWordFile-JYBuvœ,œnameœ:œchunksœ,œoutput_typesœ:[œDataœ]}",
          "targetHandle": "{œfieldNameœ:œdataœ,œidœ:œParseData-ocaSNœ,œinputTypesœ:[œDataœ],œtypeœ:œotherœ}"
        },
        {
          "id": "reactflow__edge-UniBaoxiaoFile-wTUfp{œdataTypeœ:œUniBaoxiaoFileœ,œidœ:œUniBaoxiaoFile-wTUfpœ,œnameœ:œcontent2œ,œoutput_typesœ:[œMessageœ]}-Prompt-NYSg3{œfieldNameœ:œqueryœ,œidœ:œPrompt-NYSg3œ,œinputTypesœ:[œMessageœ,œTextœ],œtypeœ:œstrœ}",
          "data": {
            "sourceHandle": {
              "id": "UniBaoxiaoFile-wTUfp",
              "name": "content2",
              "dataType": "UniBaoxiaoFile",
              "output_types": [
                "Message"
              ]
            },
            "targetHandle": {
              "id": "Prompt-NYSg3",
              "type": "str",
              "fieldName": "query",
              "inputTypes": [
                "Message",
                "Text"
              ]
            }
          },
          "source": "UniBaoxiaoFile-wTUfp",
          "target": "Prompt-NYSg3",
          "className": "",
          "sourceHandle": "{œdataTypeœ:œUniBaoxiaoFileœ,œidœ:œUniBaoxiaoFile-wTUfpœ,œnameœ:œcontent2œ,œoutput_typesœ:[œMessageœ]}",
          "targetHandle": "{œfieldNameœ:œqueryœ,œidœ:œPrompt-NYSg3œ,œinputTypesœ:[œMessageœ,œTextœ],œtypeœ:œstrœ}"
        },
        {
          "id": "reactflow__edge-OpenAICompatibleModel-cxm6H{œdataTypeœ:œOpenAICompatibleModelœ,œidœ:œOpenAICompatibleModel-cxm6Hœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}-UniChatOutput-hi43z{œfieldNameœ:œinput_valueœ,œidœ:œUniChatOutput-hi43zœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
          "data": {
            "sourceHandle": {
              "id": "OpenAICompatibleModel-cxm6H",
              "name": "text_output",
              "dataType": "OpenAICompatibleModel",
              "output_types": [
                "Message"
              ]
            },
            "targetHandle": {
              "id": "UniChatOutput-hi43z",
              "type": "str",
              "fieldName": "input_value",
              "inputTypes": [
                "Message"
              ]
            }
          },
          "source": "OpenAICompatibleModel-cxm6H",
          "target": "UniChatOutput-hi43z",
          "className": "",
          "sourceHandle": "{œdataTypeœ:œOpenAICompatibleModelœ,œidœ:œOpenAICompatibleModel-cxm6Hœ,œnameœ:œtext_outputœ,œoutput_typesœ:[œMessageœ]}",
          "targetHandle": "{œfieldNameœ:œinput_valueœ,œidœ:œUniChatOutput-hi43zœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
        },
        {
          "id": "reactflow__edge-UniChatInput-ViEcc{œdataTypeœ:œUniChatInputœ,œidœ:œUniChatInput-ViEccœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}-ParseURL-CLLZq{œfieldNameœ:œtextstr1œ,œidœ:œParseURL-CLLZqœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}",
          "data": {
            "sourceHandle": {
              "id": "UniChatInput-ViEcc",
              "name": "message",
              "dataType": "UniChatInput",
              "output_types": [
                "Message"
              ]
            },
            "targetHandle": {
              "id": "ParseURL-CLLZq",
              "type": "str",
              "fieldName": "textstr1",
              "inputTypes": [
                "Message"
              ]
            }
          },
          "source": "UniChatInput-ViEcc",
          "target": "ParseURL-CLLZq",
          "sourceHandle": "{œdataTypeœ:œUniChatInputœ,œidœ:œUniChatInput-ViEccœ,œnameœ:œmessageœ,œoutput_typesœ:[œMessageœ]}",
          "targetHandle": "{œfieldNameœ:œtextstr1œ,œidœ:œParseURL-CLLZqœ,œinputTypesœ:[œMessageœ],œtypeœ:œstrœ}"
        }
      ],
      "nodes": [
        {
          "id": "UniBaoxiaoFile-wTUfp",
          "data": {
            "id": "UniBaoxiaoFile-wTUfp",
            "node": {
              "beta": false,
              "icon": "file-text",
              "edited": false,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "content",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "load_file",
                  "selected": "Message",
                  "display_name": "Content"
                },
                {
                  "name": "content2",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "load_url",
                  "selected": "Message",
                  "display_name": "url对应的Content"
                }
              ],
              "template": {
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "# -*- coding: utf-8 -*-\nfrom pathlib import Path\nimport os\nimport json\nfrom axiestudio.custom import Component\nfrom axiestudio.inputs import StrInput\nfrom axiestudio.io import FileInput, Output\nfrom axiestudio.schema.message import Message\nfrom axiestudio.schema import Data\nimport pandas as pd\nimport uuid\nimport requests\nfrom urllib.parse import urlparse\n\nclass UniBaoxiaoFileComponent(Component):\n    display_name = \"UniBaoxiaoFile\"\n    description = \"报销单解析\"\n    icon = \"file-text\"\n    name = \"UniBaoxiaoFile\"\n    \n    TEXT_FILE_TYPES=['xlsx','xls']\n    \n    inputs = [\n        StrInput(name=\"document_id\", display_name=\"文档ID\", value=\"None\"),\n        MultilineInput(name=\"excelurl\", display_name=\"文档url\",value=\"None\"),\n        FileInput(\n            name=\"path\",\n            display_name=\"Path\",\n            file_types=TEXT_FILE_TYPES,\n            info=f\"Supported file types: {', '.join(TEXT_FILE_TYPES)}\"\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"Content\", name=\"content\", method=\"load_file\"),\n        Output(display_name=\"url对应的Content\", name=\"content2\", method=\"load_url\"),\n    ]\n    \n    def download_file(self,url):\n        response = requests.get(url, stream=True,verify=False)\n        response.raise_for_status()\n        download_dir = 'download'\n        os.makedirs(download_dir, exist_ok=True)\n        file_name = os.path.basename(urlparse(url).path)\n        print(\"下载文件名是\",file_name)\n        file_path = os.path.join(download_dir, file_name)\n        print(\"下载文件路径是\",file_path)\n        with open(file_path, 'wb') as file:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:\n                    file.write(chunk)\n                #\n            #\n        #\n        return file_path\n    #enddef\n    \n    def load_file(self) -> Message:\n        if not self.path:\n            raise ValueError(\"请上传excel文件\")\n        #\n        a=self.path\n        document_url=self.resolve_path(self.path)\n        if(a.find('http:')>=0 or a.find('https:')>=0):\n            urltmp=a[a.find('http:'):].replace('\\\\','/').replace('http:/','http://')\n            if a.find('https:')>=0:\n                urltmp=a[a.find('https:'):].replace('\\\\','/').replace('https:/','https://')\n            #\n            print(urltmp)\n            document_url=urltmp\n            self.path=self.download_file(urltmp)\n        #endif\n        print(self.path)\n        resolved_path = self.resolve_path(self.path)\n        extension = Path(resolved_path).suffix[1:].lower()\n        print(extension)\n        if extension != \"xlsx\" and extension != \"xls\":\n            raise ValueError(\"The files are not supported. Please save as .xlsx\")\n        #end\n        #解析excel\n        file_path =resolved_path\n        file_name=file_path\n        if(file_path.find('/')>=0):\n            file_name = file_path.split(\"/\")[-1]\n        else:\n            file_name = file_path.split(\"\\\\\")[-1]\n        #endif\n        excel_data = pd.read_excel(file_path,skiprows=1,index_col=None)\n        rows=json.loads(excel_data.to_json(orient='records',force_ascii=False))\n        content_field=excel_data.columns.tolist()\n        items=[]\n        index=1\n        for row in rows:\n            #print(row)\n            title='费用类型_'+row['费用类型名称']+'（'+str(row['明细序号'])+'）'\n            bxcontent=title+':'+\"费用承担部门是'\"+row['费用承担部门名称']+\"', 费用类型是'\"+row['费用类型名称']\n            if(row['标题']):\n                bxcontent=bxcontent+\"', 摘要内容是'\"+row['标题']\n            #\n            if(row['费用申请部门名称']):\n                bxcontent=bxcontent+\"', 费用申请部门是'\"+row['费用申请部门名称']\n            #\n            if(row['企业账户名称']):\n                bxcontent=bxcontent+\"', 发票抬头是'\"+row['企业账户名称']\n            #\n            if(row['费用主体名称']):\n                bxcontent=bxcontent+\"', 报销单抬头是'\"+row['费用主体名称']\n            #\n            if(row['岗位预置名称']):\n                bxcontent=bxcontent+\"', 岗位类别是'\"+row['岗位预置名称']\n            #\n            if(row['科目名称']):\n                bxcontent=bxcontent+\"', 报销类型是'\"+row['科目名称']\n            #\n            if(row['账单日期']):\n                bxcontent=bxcontent+\"', 账单日期是'\"+row['账单日期']\n            #\n            if(row['报销日期']):\n                bxcontent=bxcontent+\"', 报销日期是'\"+row['报销日期']\n            #\n            if(row['发票日期']):\n                bxcontent=bxcontent+\"', 发票日期是'\"+row['发票日期']\n            #\n            if(row['费用金额']>0):\n                bxcontent=bxcontent+\"', 费用金额是\"+str(row['费用金额'])+\"元\"\n            #\n            #if(row['报销金额']>0):\n            #    bxcontent=bxcontent+\"', 报销金额是'\"+str(row['报销金额'])+\"元'\"\n            #\n            #print(bxcontent)\n            items.append(bxcontent)\n            index=index+1\n        #endfor\n        allresult='\\n\\n'.join(items)\n        self.status = allresult\n        os.remove(self.path)\n        return allresult\n    #\n    def load_url(self) -> Message:\n        if(self.excelurl=='None'):\n            raise ValueError(\"缺少报销单url地址，请提供报销单的url\")\n        #endif\n        self.path=self.download_file(self.excelurl)\n        resolved_path = self.resolve_path(self.path)\n        extension = Path(resolved_path).suffix[1:].lower()\n        print(extension)\n        if extension != \"xlsx\" and extension != \"xls\":\n            raise ValueError(\"The files are not supported. Please save as .xlsx\")\n        #end\n        #解析excel\n        file_path =resolved_path\n        file_name=file_path\n        if(file_path.find('/')>=0):\n            file_name = file_path.split(\"/\")[-1]\n        else:\n            file_name = file_path.split(\"\\\\\")[-1]\n        #endif\n        excel_data = pd.read_excel(file_path,skiprows=1,index_col=None)\n        rows=json.loads(excel_data.to_json(orient='records',force_ascii=False))\n        content_field=excel_data.columns.tolist()\n        items=[]\n        index=1\n        for row in rows:\n            #print(row)\n            title='费用类型_'+row['费用类型名称']+'（'+str(row['明细序号'])+'）'\n            bxcontent=title+':'+\"费用承担部门是'\"+row['费用承担部门名称']+\"', 费用类型是'\"+row['费用类型名称']\n            if(row['标题']):\n                bxcontent=bxcontent+\"', 摘要内容是'\"+row['标题']\n            #\n            if(row['费用申请部门名称']):\n                bxcontent=bxcontent+\"', 费用申请部门是'\"+row['费用申请部门名称']\n            #\n            if(row['企业账户名称']):\n                bxcontent=bxcontent+\"', 发票抬头是'\"+row['企业账户名称']\n            #\n            if(row['费用主体名称']):\n                bxcontent=bxcontent+\"', 报销单抬头是'\"+row['费用主体名称']\n            #\n            if(row['岗位预置名称']):\n                bxcontent=bxcontent+\"', 岗位类别是'\"+row['岗位预置名称']\n            #\n            if(row['科目名称']):\n                bxcontent=bxcontent+\"', 报销类型是'\"+row['科目名称']\n            #\n            if(row['账单日期']):\n                bxcontent=bxcontent+\"', 账单日期是'\"+row['账单日期']\n            #\n            if(row['报销日期']):\n                bxcontent=bxcontent+\"', 报销日期是'\"+row['报销日期']\n            #\n            if(row['发票日期']):\n                bxcontent=bxcontent+\"', 发票日期是'\"+row['发票日期']\n            #\n            if(row['费用金额']>0):\n                bxcontent=bxcontent+\"', 费用金额是\"+str(row['费用金额'])+\"元\"\n            #\n            #if(row['报销金额']>0):\n            #    bxcontent=bxcontent+\"', 报销金额是'\"+str(row['报销金额'])+\"元'\"\n            #\n            #print(bxcontent)\n            items.append(bxcontent)\n            index=index+1\n        #endfor\n        allresult='\\n\\n'.join(items)\n        self.status = allresult\n        os.remove(self.path)\n        return allresult\n    #\n#\n",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "path": {
                  "info": "Supported file types: xlsx, xls",
                  "list": false,
                  "name": "path",
                  "show": true,
                  "type": "file",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "fileTypes": [
                    "xlsx",
                    "xls"
                  ],
                  "file_path": "",
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Path",
                  "trace_as_metadata": true
                },
                "_type": "Component",
                "excelurl": {
                  "info": "",
                  "list": false,
                  "name": "excelurl",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "multiline": true,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "文档url",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "document_id": {
                  "info": "",
                  "list": false,
                  "name": "document_id",
                  "show": true,
                  "type": "str",
                  "value": "None",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "文档ID",
                  "load_from_db": false,
                  "trace_as_metadata": true
                }
              },
              "description": "报销单解析",
              "field_order": [
                "document_id",
                "excelurl",
                "path"
              ],
              "base_classes": [
                "Message"
              ],
              "display_name": "UniBaoxiaoFile",
              "output_types": [],
              "custom_fields": {},
              "documentation": "",
              "conditional_paths": []
            },
            "type": "UniBaoxiaoFile",
            "description": "报销单解析",
            "display_name": "UniBaoxiaoFile"
          },
          "type": "genericNode",
          "width": 384,
          "height": 529,
          "dragging": false,
          "position": {
            "x": -797.3742033098308,
            "y": 735.6803663468979
          },
          "selected": false,
          "positionAbsolute": {
            "x": -797.3742033098308,
            "y": 735.6803663468979
          }
        },
        {
          "id": "ParseURL-CLLZq",
          "data": {
            "id": "ParseURL-CLLZq",
            "node": {
              "beta": false,
              "icon": "/zy-icons/UniCombineTextComponent.png",
              "edited": false,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "url_text",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "geturl",
                  "selected": "Message",
                  "display_name": "url"
                }
              ],
              "template": {
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "# -*- coding: utf-8 -*-\nfrom axiestudio.custom import Component\nfrom axiestudio.io import MessageTextInput, Output\nfrom axiestudio.schema.message import Message\nfrom axiestudio.utils.MinioUtils import MinioUtils\nimport re\n\nclass ParseURLComponent(Component):\n    display_name = \"获取字符串中的url\"\n    description = \"获取字符串中的url\"\n    icon = \"merge\"\n    name = \"ParseURL\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"textstr1\",\n            display_name=\"文本\",\n            info=\"文本\"\n        )\n    ]\n\n    outputs = [\n        Output(display_name=\"url\", name=\"url_text\", method=\"geturl\"),\n    ]\n    \n    def extract_urls(self,text):\n        url_pattern = r'https?://[^\\s]+'\n        urls = re.findall(url_pattern, text)\n        return urls\n    #\n    def __init__(self, **kwargs):\n        # 调用父类的初始化方法\n        super().__init__(**kwargs)\n        self.icon= MinioUtils().get_full_path('zy-icons', 'UniCombineTextComponent.png')\n    def geturl(self) -> Message:\n        extracted_urls = self.extract_urls(self.textstr1)\n        if len(extracted_urls)>0:\n            myurl=extracted_urls[0]\n            self.status =myurl\n            return Message(text=myurl)\n        else:\n            self.status ='None'\n            return Message(text='None')\n        #endif\n    #\n#\n",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "_type": "Component",
                "textstr1": {
                  "info": "文本",
                  "list": false,
                  "name": "textstr1",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "文本",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                }
              },
              "description": "获取字符串中的url",
              "field_order": [
                "textstr1"
              ],
              "base_classes": [
                "Message"
              ],
              "display_name": "获取字符串中的url",
              "output_types": [],
              "custom_fields": {},
              "documentation": "",
              "conditional_paths": []
            },
            "type": "ParseURL"
          },
          "type": "genericNode",
          "width": 384,
          "height": 309,
          "dragging": false,
          "position": {
            "x": -1305.6186941068,
            "y": 424.44929241865594
          },
          "selected": false,
          "positionAbsolute": {
            "x": -1305.6186941068,
            "y": 424.44929241865594
          }
        },
        {
          "id": "Prompt-NYSg3",
          "data": {
            "id": "Prompt-NYSg3",
            "node": {
              "beta": false,
              "icon": "prompts",
              "name": "",
              "error": null,
              "edited": false,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "prompt",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "hidden": null,
                  "method": "build_prompt",
                  "selected": "Message",
                  "display_name": "Prompt Message"
                }
              ],
              "is_input": null,
              "template": {
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "from axiestudio.base.prompts.api_utils import process_prompt_template\nfrom axiestudio.custom import Component\nfrom axiestudio.io import Output, PromptInput\nfrom axiestudio.schema.message import Message\nfrom axiestudio.template.utils import update_template_values\n\n\nclass PromptComponent(Component):\n    display_name: str = \"Prompt\"\n    description: str = \"Create a prompt template with dynamic variables.\"\n    icon = \"prompts\"\n    trace_type = \"prompt\"\n    name = \"Prompt\"\n\n    inputs = [\n        PromptInput(name=\"template\", display_name=\"Template\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Prompt Message\", name=\"prompt\", method=\"build_prompt\"),\n    ]\n\n    async def build_prompt(\n        self,\n    ) -> Message:\n        prompt = await Message.from_template_and_variables(**self._attributes)\n        self.status = prompt.text\n        return prompt\n\n    def post_code_processing(self, new_build_config: dict, current_build_config: dict):\n        \"\"\"\n        This function is called after the code validation is done.\n        \"\"\"\n        frontend_node = super().post_code_processing(new_build_config, current_build_config)\n        template = frontend_node[\"template\"][\"template\"][\"value\"]\n        _ = process_prompt_template(\n            template=template,\n            name=\"template\",\n            custom_fields=frontend_node[\"custom_fields\"],\n            frontend_node_template=frontend_node[\"template\"],\n        )\n        # Now that template is updated, we need to grab any values that were set in the current_build_config\n        # and update the frontend_node with those values\n        update_template_values(new_template=frontend_node, previous_template=current_build_config[\"template\"])\n        return frontend_node\n",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "_type": "Component",
                "query": {
                  "info": "",
                  "list": false,
                  "name": "query",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "password": false,
                  "required": false,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "field_type": "str",
                  "title_case": false,
                  "input_types": [
                    "Message",
                    "Text"
                  ],
                  "placeholder": "",
                  "display_name": "query",
                  "load_from_db": false
                },
                "context": {
                  "info": "",
                  "list": false,
                  "name": "context",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "password": false,
                  "required": false,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "field_type": "str",
                  "title_case": false,
                  "input_types": [
                    "Message",
                    "Text"
                  ],
                  "placeholder": "",
                  "display_name": "context",
                  "load_from_db": false
                },
                "template": {
                  "info": "",
                  "list": false,
                  "name": "template",
                  "show": true,
                  "type": "prompt",
                  "value": "1. 根据提供的报销规则如下：\n{context}\n---------------------------------------------------------\n2. 报销条目如下：\n---------------------------------------------------------\n【{query}】\n---------------------------------------------------------\n3. 对上面多条报销逐一进行合规性检查，并给出结论。",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Template",
                  "load_from_db": false,
                  "trace_as_input": true
                }
              },
              "full_path": null,
              "is_output": null,
              "description": "Create a prompt template with dynamic variables.",
              "field_order": [
                "template"
              ],
              "base_classes": [
                "Message"
              ],
              "display_name": "Prompt",
              "output_types": [],
              "custom_fields": {
                "template": [
                  "context",
                  "query"
                ]
              },
              "documentation": "",
              "is_composition": null,
              "conditional_paths": []
            },
            "type": "Prompt",
            "description": "Create a prompt template with dynamic variables.",
            "display_name": "Prompt"
          },
          "type": "genericNode",
          "width": 384,
          "height": 517,
          "dragging": false,
          "position": {
            "x": -1027.5202725078598,
            "y": 1380.9370385186064
          },
          "selected": false,
          "positionAbsolute": {
            "x": -1027.5202725078598,
            "y": 1380.9370385186064
          }
        },
        {
          "id": "ParseData-ocaSN",
          "data": {
            "id": "ParseData-ocaSN",
            "node": {
              "beta": false,
              "icon": "braces",
              "edited": false,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "text",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "parse_data",
                  "selected": "Message",
                  "display_name": "Text"
                }
              ],
              "template": {
                "sep": {
                  "info": "",
                  "list": false,
                  "name": "sep",
                  "show": true,
                  "type": "str",
                  "value": "\n",
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Separator",
                  "load_from_db": false,
                  "trace_as_metadata": true
                },
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "from axiestudio.custom import Component\nfrom axiestudio.helpers.data import data_to_text\nfrom axiestudio.io import DataInput, MultilineInput, Output, StrInput\nfrom axiestudio.schema.message import Message\n\n\nclass ParseDataComponent(Component):\n    display_name = \"Parse Data\"\n    description = \"Convert Data into plain text following a specified template.\"\n    icon = \"braces\"\n    name = \"ParseData\"\n\n    inputs = [\n        DataInput(name=\"data\", display_name=\"Data\", info=\"The data to convert to text.\"),\n        MultilineInput(\n            name=\"template\",\n            display_name=\"Template\",\n            info=\"The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.\",\n            value=\"{text}\",\n        ),\n        StrInput(name=\"sep\", display_name=\"Separator\", advanced=True, value=\"\\n\"),\n    ]\n\n    outputs = [\n        Output(display_name=\"Text\", name=\"text\", method=\"parse_data\"),\n    ]\n\n    def parse_data(self) -> Message:\n        data = self.data if isinstance(self.data, list) else [self.data]\n        template = self.template\n\n        result_string = data_to_text(template, data, sep=self.sep)\n        self.status = result_string\n        return Message(text=result_string)\n",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "data": {
                  "info": "The data to convert to text.",
                  "list": false,
                  "name": "data",
                  "show": true,
                  "type": "other",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Data"
                  ],
                  "placeholder": "",
                  "display_name": "Data",
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "_type": "Component",
                "template": {
                  "info": "The template to use for formatting the data. It can contain the keys {text}, {data} or any other key in the Data.",
                  "list": false,
                  "name": "template",
                  "show": true,
                  "type": "str",
                  "value": "{text}",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "multiline": true,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "Template",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                }
              },
              "description": "Convert Data into plain text following a specified template.",
              "field_order": [
                "data",
                "template",
                "sep"
              ],
              "base_classes": [
                "Message"
              ],
              "display_name": "Parse Data",
              "output_types": [],
              "custom_fields": {},
              "documentation": "",
              "conditional_paths": []
            },
            "type": "ParseData"
          },
          "type": "genericNode",
          "width": 384,
          "height": 385,
          "dragging": false,
          "position": {
            "x": -1472.0572270984728,
            "y": 1202.2056856419683
          },
          "selected": false,
          "positionAbsolute": {
            "x": -1472.0572270984728,
            "y": 1202.2056856419683
          }
        },
        {
          "id": "OpenAICompatibleModel-cxm6H",
          "data": {
            "id": "OpenAICompatibleModel-cxm6H",
            "node": {
              "beta": false,
              "icon": "OpenAI",
              "edited": false,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "text_output",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "text_response",
                  "selected": "Message",
                  "display_name": "文本"
                },
                {
                  "name": "model_output",
                  "cache": true,
                  "types": [
                    "LanguageModel"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "build_model",
                  "selected": "LanguageModel",
                  "display_name": "语言模型"
                }
              ],
              "template": {
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "# -*- coding: utf-8 -*-\nimport os\nimport operator\nfrom functools import reduce\n\nfrom langchain_openai import ChatOpenAI\nfrom pydantic.v1 import SecretStr\nfrom langfuse import Langfuse\nfrom axiestudio.base.constants import STREAM_INFO_TEXT\nfrom axiestudio.base.models.model import LCModelComponent\nfrom axiestudio.base.models.openai_constants import MODEL_NAMES\nfrom axiestudio.field_typing import LanguageModel\nfrom axiestudio.inputs import (\n    BoolInput,\n    DictInput,\n    DropdownInput,\n    FloatInput,\n    IntInput,\n    MessageInput,\n    SecretStrInput,\n    StrInput,\n)\n\nfrom langchain_core.language_models.llms import LLM\nfrom langchain_core.messages import AIMessage, BaseMessage, HumanMessage, SystemMessage\nfrom axiestudio.custom import Component\nfrom axiestudio.schema.message import Message\nfrom axiestudio.template.field.base import Output\nimport json\nimport warnings\nfrom typing import Optional, Union\n\n\nclass OpenAICompatibleModelComponent(LCModelComponent):\n    display_name = \"OpenAI Compatible\"\n    description = \"Generates text using OpenAI LLMs.\"\n    icon = \"OpenAI\"\n    name = \"OpenAICompatibleModel\"\n\n    inputs = [\n        MessageInput(name=\"input_value\", display_name=\"Input\",value=\"hello\"),\n        IntInput(\n            name=\"max_tokens\",\n            display_name=\"Max Tokens\",\n            advanced=True,\n            info=\"The maximum number of tokens to generate. Set to 0 for unlimited tokens.\",\n        ),\n        StrInput(\n            name=\"model_name\",\n            display_name=\"Model Name\",\n            info=\"the model name. Defaults to 'chatglm3' if not specified.\",\n            value=\"chatglm3\",\n        ),\n        StrInput(\n            name=\"openai_api_base\",\n            display_name=\"OpenAI API Base\",\n            value=\"http://10.0.50.33:9997/v1\",\n            info=\"The base URL of the OpenAI compatible API. Defaults to http://10.0.50.33:9997/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.\",\n        ),\n        StrInput(\n            name=\"openai_api_key\",\n            display_name=\"OpenAI API Key\",\n            info=\"The OpenAI API Key to use for the OpenAI model.\",\n            value=\"sk-2c3a4cb458884f9897529d26a44f403f\",\n        ),\n        FloatInput(name=\"temperature\", display_name=\"Temperature\", value=0.1),\n        BoolInput(name=\"stream\", display_name=\"Stream\", info=STREAM_INFO_TEXT, advanced=True),\n        StrInput(\n            name=\"system_message\",\n            display_name=\"System Message\",\n            info=\"System message to pass to the model.\",\n            advanced=True,\n        )\n    ]\n\n    def build_model(self) -> LanguageModel:  # type: ignore[type-var]\n        # self.output_schea is a list of dictionarie s\n        myopenai_api_key = self.openai_api_key\n        temperature = self.temperature\n        model_name: str = self.model_name\n        openai_api_base = self.openai_api_base or \"http://10.0.50.33:9997/v1\"\n        try:\n            output = ChatOpenAI(model=model_name,base_url=openai_api_base,openai_api_base=openai_api_base,openai_api_key=myopenai_api_key,model_name=model_name,openai_proxy=\"\",temperature=temperature)\n        except Exception as e:\n            raise ValueError(\"Could not initialize ChatOpenAI LLM.\") from e\n        #\n        return output  # type: ignore\n    #end\n    def text_response(self) -> Message:\n        input_value = self.input_value\n        stream = self.stream\n        system_message = self.system_message\n        output = self.build_model()\n        result = self.get_chat_result(output, stream, input_value, system_message)\n        self.status = result\n        return result\n    #\n    \n    def get_chat_result(\n        self,\n        runnable: LanguageModel,\n        stream: bool,\n        input_value: str | Message,\n        system_message: Optional[str] = None,\n    ):\n        messages: list[Union[BaseMessage]] = []\n        if not input_value and not system_message:\n            raise ValueError(\"The message you want to send to the model is empty.\")\n        if system_message:\n            messages.append(SystemMessage(content=system_message))\n        if input_value:\n            if isinstance(input_value, Message):\n                with warnings.catch_warnings():\n                    warnings.simplefilter(\"ignore\")\n                    if \"prompt\" in input_value:\n                        prompt = input_value.load_lc_prompt()\n                        runnable = prompt | runnable\n                    else:\n                        messages.append(input_value.to_lc_message())\n                    #\n            else:\n                messages.append(HumanMessage(content=input_value))\n        inputs: Union[list, dict] = messages or {}\n        try:\n            runnable = runnable.with_config( \n                {\"run_name\": self.display_name, \"project_name\": self.tracing_service.project_name}\n            )\n            if stream:\n                return runnable.stream(inputs) \n            else:\n                #myLangfuse = Langfuse(secret_key=\"sk-lf-56f301e0-82c4-44c3-bee2-7bac283c984b\",public_key=\"pk-lf-96f4a175-d1f9-4a69-9d8f-f0559228fbb7\",host=\"http://10.0.53.214:3000\")\n                myLangfuse = Langfuse(secret_key=os.getenv(\"LANGFUSE_SECRET_KEY\"),public_key=os.getenv(\"LANGFUSE_PUBLIC_KEY\"),host=os.getenv(\"LANGFUSE_HOST\"))\n                trace = myLangfuse.trace(name='大模型trace',user_id=\"LLM\")\n                langfuse_handler_trace = trace.get_langchain_handler()\n                message = runnable.invoke(inputs,config={\"callbacks\": [langfuse_handler_trace]})\n                result = message.content if hasattr(message, \"content\") else message\n                if isinstance(message, AIMessage):\n                    status_message = self.build_status_message(message)\n                    self.status = status_message\n                elif isinstance(result, dict):\n                    result = json.dumps(message, indent=4)\n                    self.status = result\n                else:\n                    self.status = result\n                return result\n        except Exception as e:\n            if message := self._get_exception_message(e):\n                raise ValueError(message) from e\n            raise e\n        #\n    #def",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "_type": "Component",
                "stream": {
                  "info": "Stream the response from the model. Streaming works only in Chat.",
                  "list": false,
                  "name": "stream",
                  "show": true,
                  "type": "bool",
                  "value": false,
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Stream",
                  "trace_as_metadata": true
                },
                "max_tokens": {
                  "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                  "list": false,
                  "name": "max_tokens",
                  "show": true,
                  "type": "int",
                  "value": "",
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Max Tokens",
                  "trace_as_metadata": true
                },
                "model_name": {
                  "info": "the model name. Defaults to 'chatglm3' if not specified.",
                  "list": false,
                  "name": "model_name",
                  "show": true,
                  "type": "str",
                  "value": "glm4-chat",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Model Name",
                  "load_from_db": false,
                  "trace_as_metadata": true
                },
                "input_value": {
                  "info": "",
                  "list": false,
                  "name": "input_value",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "Input",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "temperature": {
                  "info": "",
                  "list": false,
                  "name": "temperature",
                  "show": true,
                  "type": "float",
                  "value": 0.1,
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Temperature",
                  "trace_as_metadata": true
                },
                "openai_api_key": {
                  "info": "The OpenAI API Key to use for the OpenAI model.",
                  "list": false,
                  "name": "openai_api_key",
                  "show": true,
                  "type": "str",
                  "value": "sk-2c3a4cb458884f9897529d26a44f403f",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "OpenAI API Key",
                  "load_from_db": false,
                  "trace_as_metadata": true
                },
                "system_message": {
                  "info": "System message to pass to the model.",
                  "list": false,
                  "name": "system_message",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "System Message",
                  "load_from_db": false,
                  "trace_as_metadata": true
                },
                "openai_api_base": {
                  "info": "The base URL of the OpenAI compatible API. Defaults to http://10.0.50.33:9997/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                  "list": false,
                  "name": "openai_api_base",
                  "show": true,
                  "type": "str",
                  "value": "http://10.0.50.33:9997/v1",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "OpenAI API Base",
                  "load_from_db": false,
                  "trace_as_metadata": true
                }
              },
              "description": "Generates text using OpenAI LLMs.",
              "field_order": [
                "input_value",
                "max_tokens",
                "model_name",
                "openai_api_base",
                "openai_api_key",
                "temperature",
                "stream",
                "system_message"
              ],
              "base_classes": [
                "LanguageModel",
                "Message"
              ],
              "display_name": "OpenAI Compatible",
              "output_types": [],
              "custom_fields": {},
              "documentation": "",
              "conditional_paths": []
            },
            "type": "OpenAICompatibleModel"
          },
          "type": "genericNode",
          "width": 384,
          "height": 701,
          "dragging": false,
          "position": {
            "x": -75.10016220370642,
            "y": 1410.8826071652743
          },
          "selected": false,
          "positionAbsolute": {
            "x": -75.10016220370642,
            "y": 1410.8826071652743
          }
        },
        {
          "id": "UniTextInput-LJTY8",
          "data": {
            "id": "UniTextInput-LJTY8",
            "node": {
              "beta": false,
              "icon": "/zy-icons/UniTextInputComponent.png",
              "edited": false,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "text",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "text_response",
                  "selected": "Message",
                  "display_name": "文本"
                }
              ],
              "template": {
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "# -*- coding: utf-8 -*-\nfrom axiestudio.base.io.text import TextComponent\nfrom axiestudio.io import MessageTextInput, Output\nfrom axiestudio.schema.message import Message\nfrom axiestudio.utils.MinioUtils import MinioUtils\n\nclass UniTextInputComponent(TextComponent):\n    display_name = \"文本输入\"\n    description = \"从调试窗口获得文本输入。\"\n    icon = \"type\"\n    name = \"UniTextInput\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"文本\",\n            info=\"要作为输入的文本。\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"文本\", name=\"text\", method=\"text_response\"),\n    ]\n    def __init__(self, **kwargs):\n        # 调用父类的初始化方法\n        super().__init__(**kwargs)\n        self.icon= MinioUtils().get_full_path('zy-icons', 'UniTextInputComponent.png')\n    def text_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n        )\n        return message\n",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "_type": "Component",
                "input_value": {
                  "info": "要作为输入的文本。",
                  "list": false,
                  "name": "input_value",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "文本",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                }
              },
              "description": "从调试窗口获得文本输入。",
              "field_order": [
                "input_value"
              ],
              "base_classes": [
                "Message"
              ],
              "display_name": "文本输入",
              "output_types": [],
              "custom_fields": {},
              "documentation": "",
              "conditional_paths": []
            },
            "type": "UniTextInput"
          },
          "type": "genericNode",
          "width": 384,
          "height": 309,
          "dragging": false,
          "position": {
            "x": -576.1338612101653,
            "y": 1529.812811799556
          },
          "selected": false,
          "positionAbsolute": {
            "x": -576.1338612101653,
            "y": 1529.812811799556
          }
        },
        {
          "id": "WordFile-JYBuv",
          "data": {
            "id": "WordFile-JYBuv",
            "node": {
              "beta": false,
              "icon": "file-text",
              "edited": true,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "chunks",
                  "cache": true,
                  "types": [
                    "Data"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "load_file",
                  "selected": "Data",
                  "display_name": "Chunks"
                }
              ],
              "template": {
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "# -*- coding: utf-8 -*-\nfrom pathlib import Path\nimport re\nimport os\nimport subprocess\nfrom langchain.docstore.document import Document\nfrom axiestudio.base.data.utils import TEXT_FILE_TYPES, parse_text_file_to_data\nfrom axiestudio.custom import Component\nfrom axiestudio.inputs import IntInput, StrInput\nfrom axiestudio.io import BoolInput, FileInput, Output,DropdownInput\nfrom axiestudio.schema import Data\n\nfrom docx import Document as docx_Document\nfrom docx.oxml import CT_P, CT_Tbl, CT_Inline\nfrom docx.text.paragraph import Paragraph\nfrom docx.table import Table\nfrom PIL import Image\nfrom io import BytesIO\nfrom rapidocr_onnxruntime import RapidOCR\nfrom enum import Enum\nimport uuid\nfrom typing import List, Optional, Any\nfrom langchain.text_splitter import RecursiveCharacterTextSplitter\n\nimport requests\nfrom urllib.parse import urlparse\n\n\nclass WordFileComponent(Component):\n    display_name = \"WordFile\"\n    description = \"A word file loader.\"\n    icon = \"file-text\"\n    name = \"WordFile\"\n    TEXT_FILE_TYPES=['docx','doc']\n    inputs = [\n        StrInput(name=\"document_id\", display_name=\"文档ID\", value=\"http://10.0.53.245:9000/sysconfig/%E7%B4%AB%E5%85%89%E4%BA%91%E6%8A%A5%E9%94%80%E5%88%B6%E5%BA%A6.docx\"),\n        FileInput(\n            name=\"path\",\n            display_name=\"Path\",\n            file_types=TEXT_FILE_TYPES,\n            info=f\"Supported file types: {', '.join(TEXT_FILE_TYPES)}\",\n            required=True\n        ),\n        BoolInput(name=\"is_ocr\", display_name=\"光学字符识别\",value=True),\n        DropdownInput(\n            name=\"split_strategy\",\n            display_name=\"切片策略\",\n            options=[\n                \"默认切分\",\n                \"自定义切片\",\n                \"整文件切片\"\n            ],\n            required=True\n        ),\n        IntInput(name=\"chunk_size\", display_name=\"切片最大长度\", value=500),\n        IntInput(name=\"chunk_overlap\", display_name=\"切片重叠最大字数\", value=50),\n        StrInput(\n            name=\"separators\",\n            display_name=\"separators\",\n            info=\"The character to split on. Defaults to newline.\",\n            value=\"\\\\n\\\\n,\\\\n,。|！|？\",\n        ),\n        BoolInput(\n            name=\"silent_errors\",\n            display_name=\"Silent Errors\",\n            advanced=True,\n            info=\"If true, errors will not raise an exception.\",\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Chunks\", name=\"chunks\", method=\"load_file\"),\n    ]\n    \n    def download_file(self,url):\n        response = requests.get(url, stream=True,verify=False)\n        response.raise_for_status()\n        download_dir = 'download'\n        os.makedirs(download_dir, exist_ok=True)\n        file_name = os.path.basename(urlparse(url).path)\n        print(\"下载文件名是\",file_name)\n        file_path = os.path.join(download_dir, file_name)\n        print(\"下载文件路径是\",file_path)\n        with open(file_path, 'wb') as file:\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:\n                    file.write(chunk)\n                #\n            #\n        #\n        return file_path\n    #enddef\n\n    def load_file(self) -> List[Data]:\n        class TableTitleDirection(Enum):\n            Row = 1,\n            Column = 2\n        #\n\n        class TableContentSpltterStyle(Enum):\n            ByRow = 1,\n            ByColumn = 2,\n            TitleJoinContent = 3\n        class TableConfig:\n            def __init__(self,\n                         has_titles: bool = True,\n                         ignore_titles: bool = False,\n                         titles_direction: TableTitleDirection = TableTitleDirection.Row,\n                         table_content_splitter_style: TableContentSpltterStyle = TableContentSpltterStyle.ByRow):\n                super().__init__()\n                self.has_titles = has_titles\n                self.ignore_titles = ignore_titles\n                self.titles_direction = titles_direction\n                self.table_content_splitter_style = table_content_splitter_style\n            #\n        #\n        class Chunk():\n            content: str\n            index: int\n            count: int\n\n            def __init__(self, content: str, count: int = 1, index: int = 0) -> None:\n                # super().__init__(content=content, count=count, index=index)\n                self.content = content\n                self.count = count\n                self.index = index\n            #\n        #\n\n        class ChineseRecursiveTextSplitter(RecursiveCharacterTextSplitter):\n            def __init__(\n                    self,\n                    separators: Optional[List[str]] = None,\n                    keep_separator: bool = True,\n                    is_separator_regex: bool = True,\n                    **kwargs: Any,\n            ) -> None:\n                \"\"\"Create a new TextSplitter.\"\"\"\n                super().__init__(keep_separator=keep_separator, **kwargs)\n                self._separators = separators or [\n                    \"\\n\\n\",\n                    \"\\n\",\n                    \"。|！|？\",\n                    r\"\\.\\s|\\!\\s|\\?\\s\",\n                    r\"；|;\\s\",\n                    r\"，|,\\s\"\n                ]\n                self._is_separator_regex = is_separator_regex\n            #\n            \n            def _split_text_with_regex_from_end(self,text: str, separator: str, keep_separator: bool) -> List[str]:\n                # Now that we have the separator, split the text\n                if separator:\n                    if keep_separator:\n                        # The parentheses in the pattern keep the delimiters in the result.\n                        _splits = re.split(f\"({separator})\", text)\n                        splits = [\"\".join(i) for i in zip(_splits[0::2], _splits[1::2])]\n                        if len(_splits) % 2 == 1:\n                            splits += _splits[-1:]\n                        # splits = [_splits[0]] + splits\n                    else:\n                        splits = re.split(separator, text)\n                else:\n                    splits = list(text)\n                return [s for s in splits if s != \"\"]\n            #\n            def _split_text(self, text: str, separators: List[str]) -> List[str]:\n                \"\"\"Split incoming text and return chunks.\"\"\"\n                final_chunks = []\n                # Get appropriate separator to use\n                separator = separators[-1]\n                new_separators = []\n                for i, _s in enumerate(separators):\n                    _separator = _s if self._is_separator_regex else re.escape(_s)\n                    if _s == \"\":\n                        separator = _s\n                        break\n                    if re.search(_separator, text):\n                        separator = _s\n                        new_separators = separators[i + 1:]\n                        break\n\n                _separator = separator if self._is_separator_regex else re.escape(separator)\n                splits = self._split_text_with_regex_from_end(text, _separator, self._keep_separator)\n\n                # Now go merging things, recursively splitting longer texts.\n                _good_splits = []\n                _separator = \"\" if self._keep_separator else separator\n                for s in splits:\n                    if self._length_function(s) < self._chunk_size:\n                        _good_splits.append(s)\n                    else:\n                        if _good_splits:\n                            merged_text = self._merge_splits(_good_splits, _separator)\n                            final_chunks.extend(merged_text)\n                            _good_splits = []\n                        if not new_separators:\n                            final_chunks.append(s)\n                        else:\n                            other_info = self._split_text(s, new_separators)\n                            final_chunks.extend(other_info)\n                if _good_splits:\n                    merged_text = self._merge_splits(_good_splits, _separator)\n                    final_chunks.extend(merged_text)\n                return [re.sub(\"\\n{2,}\", \"\\n\", chunk.strip()) for chunk in final_chunks if chunk.strip()!=\"\"]\n\n        #\n\n        class TableCategory(Enum):\n            TOTAL = 1\n\n\n        class WordLoaderSplitterManager:\n            def __init__(self,\n                         table_config: TableConfig = None,\n                         chunk_size: int = 500,\n                         chunk_overlap: int = 50,\n                         separators: Optional[List[str]] = None,\n                         keep_separator: bool = True,\n                         is_separator_regex: bool = True,\n                         is_notfill: bool=False,\n                         is_ocr: bool=False\n                         ) -> None:\n                super().__init__()\n                self._separators = separators or [\n                    \"\\n\\n\",\n                    \"\\n\",\n                    \"。|！|？\",\n                    r\"\\.\\s|\\!\\s|\\?\\s\",\n                    r\"；|;\\s\",\n                    r\"，|,\\s\"\n                ]\n\n                self.table_config = table_config\n                self._is_separator_regex = is_separator_regex\n                # 待切分处理的\n                self.long_content = \"\"\n                #默认弄这种：下文与({self.file_name}#{heading_text})有关\n                self.notfill=is_notfill\n                self.is_ocr=is_ocr\n                #word文档\n                self.doc=None\n                # 切片数组\n                self.chunk_list: [Chunk] = []\n                self.chunk_text_list: [str] = []\n                # 标题\n                self.headings = {}  # {\"Heading_1\": \"\"}\n                self.chunk_size = chunk_size\n                self.chunk_overlap = chunk_overlap\n                # 默认使用表格前的一段文字作为整个表格的标题\n                self.ex_text = \"\"\n                self.ocr = RapidOCR()\n                self.file_name = \"\"\n                self.file_path = \"\"\n\n            # 标题-目录\n            def _get_headings_list(self):\n                return self.headings.values() if self.headings else None\n            #\n            def handle_page_ocr_result(self,ocr_result: []):\n                if ocr_result is None or len(ocr_result) == 0:\n                    return\n\n                ocr_text = \"\"\n                new_line = \"\"\n\n                ex_box = None\n\n                for i, block in enumerate(ocr_result):\n                    if len(block) != 3:\n                        continue\n                    box = block[0]\n                    txt = block[1]\n                    conf = block[2]\n\n                    # x00, y00 ----- x01, y01\n                    #          |    |\n                    # x10, y10 ----- x11, y11\n                    x00, y00 = box[0]\n                    x01, y01 = box[1]\n                    x11, y11 = box[2]\n                    x10, y10 = box[3]\n                    txt = self.data_pre_process(txt)\n                    if len(txt.strip()) == 0:\n                        continue\n\n                    if ex_box is None:\n                        ex_box = box\n                        new_line = txt\n                        # 判断是否是同一行\n                    elif ex_box[3][1] > y00:\n                        new_line = f\"{new_line} {txt}\"\n                    else:\n                        ocr_text = f\"{ocr_text}\\n{new_line}\"\n                        new_line = txt\n                        ex_box = box\n\n                    new_line = self.data_cleaning(new_line)\n\n                ocr_text = f\"{ocr_text}\\n{new_line}\"\n                return ocr_text\n\n            def data_pre_process(self,text: str):\n                if len(text) == 0:\n                    return None\n                return self.data_cleaning(text)\n\n\n            def data_cleaning(self,text: str):\n                cleaned_text = self.clean_except_value(text)\n                cleaned_text = self.clean_page_number(cleaned_text)\n                return cleaned_text\n\n            def clean_except_value(self,text: str):\n                cleaned_text = text\n                # 固定的异常字符\n                exception_txt_list = [\"il\"]\n\n                for except_txt in exception_txt_list:\n                    cleaned_text = text.replace(except_txt, \"\")\n\n                return cleaned_text\n            # 清洗页码\n            def clean_page_number(self,text: str):\n                pattern = r'^\\s*一\\s*\\d+\\s*一$'\n                if bool(re.match(pattern, text)):\n                    cleaned_text = re.sub(pattern, '', text, flags=re.IGNORECASE)\n                    return cleaned_text\n                return text\n            #\n            \n            # 判断是否是标题\n            def _is_title(self,text, font_size = None, bold = None, separators: [] = None):\n                keywords = [\"\"]\n\n                # 长度\n                if len(text) == 0 or len(text) > 20:\n                    return False\n\n                for element in separators:\n                    if element in text:\n                        return False\n                    #\n                #    \n                # 字体大小\n                if font_size and font_size > 12:\n                    return True\n\n                # 加粗\n                if bold:\n                    return True\n\n                # 大写\n                if text.isupper() or text.istitle():\n                    return True\n\n                # 特定关键词\n                for keyword in keywords:\n                    if keyword in text:\n                        return True\n\n                return False\n            #endif\n            \n            def get_parent_childrens(self,smallchunks):\n                cont = []\n                pos = []\n                for p in self.doc.paragraphs:\n                    #print(p.style.name)\n                    #print(p.text)\n                    style_name = p.style.name\n                    if style_name.startswith('Heading'):\n                        #print(style_name,p.text,sep=':')\n                        pos.append(int(style_name[-1]))\n                        cont.append(p.text)\n                    #\n                #endfor\n                # construct keys\n                # input=[1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 3, 3]\n                # output = ['1', '1-1', '1-2', '2', '2-1', '2-2', '2-3', '3', '3-1', '3-2', '3-2-1', '3-2-2']\n                keys = ['0'] * len(pos)\n                def dfs(p, f):\n                    x = 1\n                    if keys[p] == '0':\n                        keys[p] = f + '-' + str(x)\n                    x += 1\n                    th = keys[p]\n                    for i in range(p+1, len(pos)):\n                        if pos[i] - 1 == pos[p]:\n                            #print(i)\n                            dfs(i, th +'-')\n                        elif pos[i] == pos[p]:\n                            if keys[i] == '0':\n                                keys[i] = f + '-' + str(x)\n                                x += 1\n                                th = keys[i]\n                        elif pos[i] + 1 == pos[p]:\n                            return\n                dfs(0, '')\n                \n                keys = [e.strip('-').replace('--', '-') for e in keys]\n                headers=[]\n                for i in range(len(keys)):\n                    headers.append({'pid':'None','next':None,'myid':str(uuid.uuid1()),'id':keys[i],'value':cont[i],'children':[]})\n                #\n                #id,pid,value,brothervalue\n                headerlist=[]\n                for i in range(0,len(headers)-1):\n                    for j in range(i+1,len(headers)):\n                        if(headers[j]['id'].find(headers[i]['id'])==0 and headers[j]['id'].replace(headers[i]['id'],'').count('-')==1):\n                            headers[j]['pid']=headers[i]['myid']\n                            headers[j]['value']=headers[i]['value']+'-'+headers[j]['value']\n                            #如果有下一个同级别的，就记录这个value\n                            if j<len(headers)-1:\n                                index1=headers[j+1]['id'].rfind('-')\n                                index2=headers[j]['id'].rfind('-')\n                                if((index1==index2) and (headers[j+1]['id'][0:index1]==headers[j]['id'][0:index1])):\n                                    headers[j]['next']=headers[j+1]['value']\n                                #endif\n                            #endif\n                            headers[i]['children'].append(headers[j])\n                        #\n                #\n                #print(headers)\n                def getItemByID(id):\n                    for i in range(0,len(headers)):\n                        if(headers[i]['id']==id):\n                            return headers[i]\n                        #nedif\n                    #endfor\n                    return None\n                #enddef\n                #如果pid是None代表是一级目录，nextvalue就是它的下一个同级目录\n                for i in range(0,len(headers)):\n                    if(headers[i]['pid']=='None'):\n                        nextid=str(int(headers[i]['id'])+1)\n                        nextItem=getItemByID(nextid)\n                        if(nextItem!=None):\n                            headers[i]['next']=nextItem['value']\n                        #endif\n                    #nedif\n                #endfor\n                #遍历每个节点，如果有children就设置children中的nextvalue，比如1-1的nextvalue是1-2,\n                #如果没有下一个兄弟节点，next就设置为父节点的nextvalue\n                for i in range(0,len(headers)):\n                    childcount=len(headers[i]['children'])\n                    if childcount>0:\n                        if(childcount==1):\n                            headers[i]['children'][0]['next']=headers[i]['next']\n                        else:\n                            for j in range(0,childcount-1):\n                                headers[i]['children'][j]['next']=headers[i]['children'][j+1]['value']\n                            #\n                            headers[i]['children'][childcount-1]['next']=headers[i]['next']\n                        #endif\n                    #endif\n                #endfor\n                parents=headers\n                alldocs=[]\n                allids=[]\n                alltxts=[]\n                for item2 in parents:\n                    myvalue=item2['value']\n                    myid=item2['myid']\n                    contentall=myvalue+'\\n\\n'\n                    for child in smallchunks:\n                        mycontent=child.page_content.split('`')\n                        childrenid=child.metadata['myid']\n                        if len(mycontent)<2:\n                            if(mycontent[0].find(myvalue)>=0):\n                                print('没识别出段落')\n                                contentall=contentall+mycontent[0]\n                                if(childrenid not in allids):\n                                    allids.append(childrenid)\n                                else:\n                                    alldocs = [item for item in alldocs if item['myid']!=childrenid]\n                                #endif\n                                alldocs.append({'myid':childrenid,'pid':myid,'content':mycontent[0],'is_parent':'-1'})\n                            #endif\n                        else:\n                            if(mycontent[0].find(myvalue)>=0):\n                                if(mycontent[0]!=myvalue):\n                                    contentall=contentall+mycontent[0][mycontent[0].rfind('-')+1:]+mycontent[1]\n                                else:\n                                    contentall=contentall+mycontent[1]\n                                #endif\n                                if(childrenid not in allids):\n                                    allids.append(childrenid)\n                                else:\n                                    alldocs = [item for item in alldocs if item['myid']!=childrenid]\n                                #\n                                alldocs.append({'myid':childrenid,'pid':myid,'content':child.page_content.replace('`','\\n\\n'),'is_parent':'0','source':self.file_path,'title':mycontent[0]})\n                            #endif\n                        #endif\n                    #endfor\n                    if len(contentall)>len(myvalue+'\\n\\n'):\n                        if(contentall.replace('-','').replace('\\n','') not in alltxts):\n                            alltxts.append(contentall.replace('-','').replace('\\n',''))\n                            alldocs.append({'myid':myid,'pid':item2['pid'],'content':contentall,'is_parent':'1','source':self.file_path,'title':myvalue})\n                        #endif\n                    #endif\n                #endfor\n                #存在文档封面等chunk，这种不存在任何父节点，需要单独处理\n                for child in smallchunks:\n                    if(child.metadata['myid'] not in allids):\n                        alldocs.insert(0,{'myid':child.metadata['myid'],'pid':'None','content':child.page_content,'is_parent':'0','source':self.file_path,'title':''})\n                    #\n                #endif\n                #big为1是合成后的，0是最小的分片，如果0和1的content完全一样，就删除big是0的\n                redundancytxts=[]\n                for i in range(len(alldocs)-1, -1, -1):\n                    tmpcontent=alldocs[i]['content'].replace('-','').replace('\\n','')\n                    if tmpcontent in alltxts and alldocs[i]['is_parent']=='0':\n                        del alldocs[i]\n                        redundancytxts.append(tmpcontent)\n                        #print('删除:'+str(i))\n                    #endif\n                #endfor\n                #父节点变is_parent变0\n                for i in range(len(alldocs)-1, -1, -1):\n                    tmpcontent=alldocs[i]['content'].replace('-','').replace('\\n','')\n                    if tmpcontent in redundancytxts and alldocs[i]['is_parent']=='1':\n                        alldocs[i]['is_parent']='0'\n                    #endif\n                #endfor\n                return alldocs\n            #\n            \n            def _get_chunk_title(self):\n                if self.headings:\n                    heading_text = \"-\".join(filter(None, self.headings.values()))\n                    if heading_text and len(heading_text) > 1:\n                        if(self.notfill):\n                            return f\"{heading_text}`\"\n                        else:\n                            return f\"下文与({self.file_name}#{heading_text})有关。\"\n                        #\n                    #\n                return \"\"\n\n            def _update_heading_dict(self, heading_name: str, heading_content: str):\n                if \"Heading\" in heading_name:\n                    num = int(heading_name.split('Heading ')[1])\n                else:\n                    # 如果是非正规word，暂时一律以一级标题处理\n                    num = 1\n\n                for key in list(self.headings):\n                    if int(key.split('Heading_')[1]) >= num:\n                        del self.headings[key]\n                heading_key = f\"Heading_{num}\"\n                self.headings[heading_key] = heading_content\n\n            def _split_text_to_chunks(self, text: str):\n\n                prefix = self._get_chunk_title()\n\n                # 预留出chunk标题的长度\n                chunk_content_size = self.chunk_size - len(prefix)\n                if chunk_content_size < 20:\n                    chunk_content_size = 20\n                #endif\n\n                if len(text) < chunk_content_size:\n                   \n                    chunk_text = f\"{prefix}{text}\"\n                    chunk = Chunk(content=chunk_text, count=1, index=1)\n                    self.chunk_text_list.append(chunk_text)\n                    return [chunk]\n                #\n\n                text_splitter = ChineseRecursiveTextSplitter(\n                    keep_separator=True,\n                    is_separator_regex=True,\n                    chunk_size=chunk_content_size,\n                    chunk_overlap=self.chunk_overlap\n                )\n\n                chunks = text_splitter.split_text(text.strip())\n\n                chunks_length = len(chunks)\n\n                result_chunks = []\n                for i, content in enumerate(chunks):\n                    chunk_text = f\"{prefix}{content}\"\n                    chunk = Chunk(content=chunk_text, count=chunks_length, index=i)\n\n                    self.chunk_text_list.append(chunk_text)\n                    result_chunks.append(chunk)\n                return result_chunks\n\n                # return [f\"{prefix}{chunk}\" for chunk in chunks if chunk]\n\n            def _process_paragraph_text(self, paragraph, paragraph_text):\n                paragraph_style_name = paragraph.style.name\n                # paragraph_text = paragraph.text\n                paragraph_text = paragraph_text\n\n                # 既是标题也是内容时，则当正文处理\n                if not paragraph_style_name.startswith(\"Heading \") or not self._is_title(paragraph_text, separators=[\"：\"]):\n                    # 不是标题，则都是正文\n                    self.long_content = f\"{self.long_content}\\n{paragraph_text}\"\n                    return\n\n                # 正文部分处理流程\n                # 遇到新标题时，需将前面累积的文本处理切片\n                # 更新标题\n                if not self.long_content:\n                    self._update_heading_dict(paragraph_style_name, paragraph_text)\n                    return\n\n                chunks = self._split_text_to_chunks(self.long_content)\n                self.chunk_list.extend(chunks)\n\n                # 置空\n                self.long_content = \"\"\n                self._update_heading_dict(paragraph_style_name, paragraph_text)\n\n            def _get_paragraph_text(self, paragraph):\n                # 一个文本段落中只有text和image，没有table\n                paragraph_content = \"\"\n                for run in paragraph.runs:\n                    # 图片\n                    blips = run.element.xpath('.//a:blip')\n                    if blips:\n                        if(self.is_ocr==False):\n                            continue\n                        #endif\n                        for blip in blips:\n                            try:\n\n                                rId = blip.embed\n                                image_part = run.part.related_parts[rId]\n                                image = Image.open(BytesIO(image_part.blob))\n                                filetype='.png'\n                                if(image.format!='PNG'):\n                                    filetype='.jpg'\n                                #\n                                myurl='images/'+str(uuid.uuid1())+filetype\n                                image.save(myurl)\n                                result, _ = self.ocr(image_part.blob)\n                                image_content = self.handle_page_ocr_result(result)\n                                if(image_content==None):\n                                    image_content=''\n                                #endif\n                                # image_content = f\"<image_content/>{image_content}</image_content>\"\n                                paragraph_content = f\"{paragraph_content}\\n![]({myurl}){image_content}\"\n\n                                # global chunk_content\n                                # chunk_content = f\"{chunk_content}\\n{paragraph_content}\"\n                            except Exception as e:\n                                print(f\"{e}\")\n                    # 文字\n                    elif run.element.text:\n                        paragraph_content = f\"{paragraph_content}{run.text}\"\n                    else:\n                        print(run)\n                if paragraph_content:\n                    self._process_paragraph_text(paragraph, paragraph_content)\n                    self.ex_text = paragraph_content\n\n            # 表格\n            def _get_table_text(self, table):\n                table_content = \"\"\n                for row in table.rows:\n                    for cell in row.cells:\n                        for paragraph in cell.paragraphs:\n                            table_content += paragraph.text.strip() + \"\\n\"\n                return table_content\n\n            def _split_table_to_chunks(self, table):\n                # self.table_config.chunk_title_format.format(title=\"\")\n                #print(self.headings.values())\n                heading_text = \"-\".join(filter(None, self.headings.values()))\n\n                chunk_title = \"\"\n                if heading_text and len(heading_text) > 1:\n                    if(self.notfill):\n                        chunk_title= f\"{heading_text}`\"\n                    else:\n                        chunk_title = f\"下文与({self.file_name}#{heading_text})有关。\"\n                    #\n                #\n\n                if self.ex_text and len(self.ex_text) < 20 and len(self.ex_text) > 1:\n                    if(self.notfill):\n                        chunk_title= f\"{heading_text}`\"\n                    else:\n                        chunk_title = f\"下文与({self.file_name}#{heading_text}#{self.ex_text})有关。\"\n                    #\n                #\n                table_chunks = []\n                title_list = []\n                table_row_length = len(table.rows) - 1\n                for i, row in enumerate(table.rows):\n                    row_content = \"\"\n                    if i == 0:\n                        for cell in row.cells:\n                            cell_content = \",\".join([paragraph.text.strip() for paragraph in cell.paragraphs if paragraph.text])\n                            # if cell_content:\n                            #     title_list.append(cell_content)\n                            title_list.append(cell_content)\n                            continue\n                        continue\n\n                    for cell_index, cell in enumerate(row.cells):\n                        cell_content = \"、\".join([paragraph.text.strip() for paragraph in cell.paragraphs if paragraph.text])\n                        if cell_content:\n                            cell_content = title_list[cell_index] + \":\" + cell_content + \";\"\n                            row_content = f\"{row_content}{cell_content}\"\n                    if row_content:\n                        row_chunk = f\"{chunk_title}\\n\\n{row_content}\"\n                        self.chunk_text_list.append(row_chunk)\n                        chunk = Chunk(content=row_chunk, count=table_row_length, index=i)\n                        table_chunks.append(chunk)\n\n                return table_chunks\n            #\n            \n            def convert_chunks(self,smallchunks):\n                items=[]\n                for child in smallchunks:\n                    if(child.page_content.find('下文与(')>=0 and child.page_content.find(')有关')>=0):\n                        title=child.page_content[child.page_content.find('下文与(')+4:child.page_content.find(')有关')]\n                        mytitle=title[title.find('#')+1:]\n                        items.append({'myid':child.metadata['myid'],'pid':'None','content':child.page_content,'is_parent':'0','source':child.metadata['source'],'title':mytitle})\n                    else:\n                        items.append({'myid':child.metadata['myid'],'pid':'None','content':child.page_content,'is_parent':'0','source':child.metadata['source'],'title':''})\n                    #endif\n                #\n                return items\n            #enddef\n            \n            def get_all_text(self,smallchunks):\n                txts=[]\n                for child in smallchunks:\n                    if(child.page_content.find('`')<0):\n                        txts.append(child.page_content)\n                    else:\n                        mycontent=child.page_content.split('`')\n                        title=mycontent[0]\n                        mytitle=title[title.rfind('-')+1:]\n                        txts.append(mytitle+'\\n'+mycontent[1])\n                    #endif\n                #\n                item={'myid':str(uuid.uuid1()),'pid':'None','content':'\\n'.join(txts),'is_parent':'0','source':self.file_path,'title':self.file_name}\n                return item\n            #enddef\n            \n            def load_and_split_file(self,file_path: str):\n                if(file_path.find('/')>=0):\n                    self.file_name = file_path.split(\"/\")[-1]\n                else:\n                    self.file_name = file_path.split(\"\\\\\")[-1]\n                #endif\n                self.file_name = os.path.splitext(self.file_name)[0]\n                self.file_path=file_path\n                from docx import Document as docx_Document\n                doc = docx_Document(file_path)\n                self.doc=doc\n\n                for element in doc.element.body:\n                    if isinstance(element, CT_P):\n                        paragraph = Paragraph(element, doc)\n                        self._get_paragraph_text(paragraph)\n                    elif isinstance(element, CT_Tbl):\n                        # 遇到表格时，处理掉上文\n                        chunks = self._split_text_to_chunks(self.long_content)\n                        self.chunk_list.extend(chunks)\n                       \n\n                        self.long_content = \"\"\n\n                        table = Table(element, doc)\n                        chunks = self._split_table_to_chunks(table)\n                        self.chunk_list.extend(chunks)\n\n                    elif isinstance(element, CT_Inline):\n                        print(f\"element:{element}\")\n                    else:\n                        print(f\"element-else:{element}\")\n\n                # 收尾\n                \n                if self.long_content:\n                    chunks = self._split_text_to_chunks(self.long_content)\n                    self.chunk_list.extend(chunks)\n                #\n                from langchain.docstore.document import Document\n                return [Document(page_content=chunk.content, metadata={\"source\": self.file_path,\"myid\":str(uuid.uuid1())}) for chunk in self.chunk_list]\n            #enddef\n        #enddef\n        current_path = Path().resolve()\n        #print(current_path)\n        myseparators = self.separators.split(',')\n        #print(myseparators)\n        a=self.path\n        #print(a)\n        document_url=self.resolve_path(self.path)\n        if(a.find('http:')>=0 or a.find('https:')>=0):\n            urltmp=a[a.find('http:'):].replace('\\\\','/').replace('http:/','http://')\n            if a.find('https:')>=0:\n                urltmp=a[a.find('https:'):].replace('\\\\','/').replace('https:/','https://')\n            #\n            print(urltmp)\n            document_url=urltmp\n            self.path=self.download_file(urltmp)\n        #endif\n        print(self.path)\n        if not self.path:\n            raise ValueError(\"Please, upload a file to use this component.\")\n        resolved_path = self.resolve_path(self.path)\n        silent_errors = self.silent_errors\n\n        extension = Path(resolved_path).suffix[1:].lower()\n        filepath =resolved_path\n        if extension == \"doc\":\n            tmp_dir = 'tmpfiles'\n            os.makedirs(tmp_dir, exist_ok=True)\n            filepath = os.path.join(tmp_dir,os.path.basename(resolved_path).replace('.doc','.docx'))\n            #doc转docx\n            subprocess.call([\"soffice\",\"--headless\",\"--convert-to\",\"docx\",\"--outdir\",tmp_dir,resolved_path])\n        #end\n        #解析word\n        table_config = TableConfig()\n        #三种切片方式\n        if(self.split_strategy=='默认切分'):\n            manager = WordLoaderSplitterManager(table_config=table_config,is_ocr=self.is_ocr)\n            smallchunks = manager.load_and_split_file(file_path=filepath)\n            items=manager.convert_chunks(smallchunks)\n        elif(self.split_strategy=='自定义切片'):\n            manager = WordLoaderSplitterManager(table_config=table_config,chunk_size=self.chunk_size,chunk_overlap=self.chunk_overlap,separators=myseparators,is_ocr=self.is_ocr)\n            smallchunks = manager.load_and_split_file(file_path=filepath)\n            items=manager.convert_chunks(smallchunks)\n        elif(self.split_strategy=='整文件切片'):\n            manager = WordLoaderSplitterManager(table_config=table_config,chunk_size=15000,is_notfill=True,is_ocr=self.is_ocr)\n            smallchunks = manager.load_and_split_file(file_path=filepath)\n            items=[manager.get_all_text(smallchunks)]\n        else:\n            manager = WordLoaderSplitterManager(table_config=table_config,is_ocr=self.is_ocr)\n            smallchunks = manager.load_and_split_file(file_path=filepath)\n            items=manager.convert_chunks(smallchunks)\n        #endif\n        #print(items)\n        datas=[]\n        for item in items:\n            mytext = item.pop('content')\n            item['document_id']=self.document_id\n            item['source']=document_url\n            datas.append(Data(text=mytext,data=item))\n        #endfor\n        self.status = datas\n        os.remove(self.path)\n        return datas\n    #\n#\n",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "path": {
                  "info": "Supported file types: docx, doc",
                  "list": false,
                  "name": "path",
                  "show": true,
                  "type": "file",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": true,
                  "fileTypes": [
                    "docx",
                    "doc"
                  ],
                  "file_path": "03736035-08a6-472e-bc3b-574b04fe9f75/紫光云报销制度.docx",
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Path",
                  "load_from_db": false,
                  "trace_as_metadata": true
                },
                "_type": "Component",
                "is_ocr": {
                  "info": "",
                  "list": false,
                  "name": "is_ocr",
                  "show": true,
                  "type": "bool",
                  "value": true,
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "光学字符识别",
                  "trace_as_metadata": true
                },
                "chunk_size": {
                  "info": "",
                  "list": false,
                  "name": "chunk_size",
                  "show": true,
                  "type": "int",
                  "value": 500,
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "切片最大长度",
                  "trace_as_metadata": true
                },
                "separators": {
                  "info": "The character to split on. Defaults to newline.",
                  "list": false,
                  "name": "separators",
                  "show": true,
                  "type": "str",
                  "value": "\\n\\n,\\n,。|！|？",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "separators",
                  "load_from_db": false,
                  "trace_as_metadata": true
                },
                "document_id": {
                  "info": "",
                  "list": false,
                  "name": "document_id",
                  "show": true,
                  "type": "str",
                  "value": "None",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "文档ID",
                  "load_from_db": false,
                  "trace_as_metadata": true
                },
                "chunk_overlap": {
                  "info": "",
                  "list": false,
                  "name": "chunk_overlap",
                  "show": true,
                  "type": "int",
                  "value": 50,
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "切片重叠最大字数",
                  "trace_as_metadata": true
                },
                "silent_errors": {
                  "info": "If true, errors will not raise an exception.",
                  "list": false,
                  "name": "silent_errors",
                  "show": true,
                  "type": "bool",
                  "value": false,
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "Silent Errors",
                  "trace_as_metadata": true
                },
                "split_strategy": {
                  "info": "",
                  "name": "split_strategy",
                  "show": true,
                  "type": "str",
                  "value": "整文件切片",
                  "dynamic": false,
                  "options": [
                    "默认切分",
                    "自定义切片",
                    "整文件切片"
                  ],
                  "advanced": false,
                  "required": true,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "切片策略",
                  "load_from_db": false,
                  "trace_as_metadata": true
                }
              },
              "description": "A word file loader.",
              "field_order": [
                "document_id",
                "path",
                "is_ocr",
                "split_strategy",
                "chunk_size",
                "chunk_overlap",
                "separators",
                "silent_errors"
              ],
              "base_classes": [
                "Data"
              ],
              "display_name": "WordFile",
              "output_types": [],
              "custom_fields": {},
              "documentation": "",
              "conditional_paths": []
            },
            "type": "WordFile",
            "description": "A word file loader.",
            "display_name": "WordFile"
          },
          "type": "genericNode",
          "width": 384,
          "height": 807,
          "dragging": false,
          "position": {
            "x": -2104.0398530855036,
            "y": 1176.7551145438565
          },
          "selected": false,
          "positionAbsolute": {
            "x": -2104.0398530855036,
            "y": 1176.7551145438565
          }
        },
        {
          "id": "UniChatOutput-hi43z",
          "data": {
            "id": "UniChatOutput-hi43z",
            "node": {
              "beta": false,
              "icon": "/zy-icons/UniChatOutputComponent.png",
              "edited": false,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "message",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "message_response",
                  "selected": "Message",
                  "display_name": "消息"
                }
              ],
              "template": {
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "# -*- coding: utf-8 -*-\nfrom axiestudio.base.io.chat import ChatComponent\nfrom axiestudio.inputs import BoolInput\nfrom axiestudio.io import DropdownInput, MessageTextInput, Output\nfrom axiestudio.memory import store_message\nfrom axiestudio.schema.message import Message\nfrom axiestudio.utils.MinioUtils import MinioUtils\n\nclass UniChatOutput(ChatComponent):\n    display_name = \"对话输出\"\n    description = \"在调试窗口中显示一条聊天消息。\"\n    icon = \"ChatOutput\"\n    name = \"UniChatOutput\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"input_value\",\n            display_name=\"文本\",\n            info=\"要输出的消息。\",\n        ),\n        BoolInput(\n            name=\"store_message\",\n            display_name=\"存储消息\",\n            info=\"将消息存储到历史记录。\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"发送者\",\n            options=[\"Machine\", \"User\"],\n            value=\"Machine\",\n            advanced=True,\n            info=\"发送者。\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\", display_name=\"发送者名称\", info=\"发送者的名称。\", value=\"AI\", advanced=True\n        ),\n        MessageTextInput(\n            name=\"session_id\", display_name=\"会话ID\", info=\"消息的会话ID。\", advanced=False\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"数据模版\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"将数据转化为文本的模版。如果为空，模版会被动态地设置为数据的文本密匙。\",\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"消息\", name=\"message\", method=\"message_response\"),\n    ]\n    def __init__(self, **kwargs):\n        # 调用父类的初始化方法\n        super().__init__(**kwargs)\n        self.icon= MinioUtils().get_full_path('zy-icons', 'UniChatOutputComponent.png')\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n        )\n        if self.session_id and isinstance(message, Message) and isinstance(message.text, str):\n            store_message(\n                message,\n                flow_id=self.graph.flow_id,\n            )\n            self.message.value = message\n\n        self.status = message\n        return message\n",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "_type": "Component",
                "sender": {
                  "info": "发送者。",
                  "name": "sender",
                  "show": true,
                  "type": "str",
                  "value": "Machine",
                  "dynamic": false,
                  "options": [
                    "Machine",
                    "User"
                  ],
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "发送者",
                  "trace_as_metadata": true
                },
                "session_id": {
                  "info": "消息的会话ID。",
                  "list": false,
                  "name": "session_id",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "会话ID",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "input_value": {
                  "info": "要输出的消息。",
                  "list": false,
                  "name": "input_value",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "文本",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "sender_name": {
                  "info": "发送者的名称。",
                  "list": false,
                  "name": "sender_name",
                  "show": true,
                  "type": "str",
                  "value": "AI",
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "发送者名称",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "data_template": {
                  "info": "将数据转化为文本的模版。如果为空，模版会被动态地设置为数据的文本密匙。",
                  "list": false,
                  "name": "data_template",
                  "show": true,
                  "type": "str",
                  "value": "{text}",
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "数据模版",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "store_message": {
                  "info": "将消息存储到历史记录。",
                  "list": false,
                  "name": "store_message",
                  "show": true,
                  "type": "bool",
                  "value": true,
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "存储消息",
                  "trace_as_metadata": true
                }
              },
              "description": "在调试窗口中显示一条聊天消息。",
              "field_order": [
                "input_value",
                "store_message",
                "sender",
                "sender_name",
                "session_id",
                "data_template"
              ],
              "base_classes": [
                "Message"
              ],
              "display_name": "对话输出",
              "output_types": [],
              "custom_fields": {},
              "documentation": "",
              "conditional_paths": []
            },
            "type": "UniChatOutput"
          },
          "type": "genericNode",
          "width": 384,
          "height": 403,
          "position": {
            "x": 541.1268216119704,
            "y": 1584.4953264560463
          },
          "selected": false
        },
        {
          "id": "UniChatInput-ViEcc",
          "data": {
            "id": "UniChatInput-ViEcc",
            "node": {
              "beta": false,
              "icon": "/zy-icons/UniChatInputComponent.png",
              "edited": false,
              "frozen": false,
              "pinned": false,
              "outputs": [
                {
                  "name": "message",
                  "cache": true,
                  "types": [
                    "Message"
                  ],
                  "value": "__UNDEFINED__",
                  "method": "message_response",
                  "selected": "Message",
                  "display_name": "消息"
                }
              ],
              "template": {
                "code": {
                  "info": "",
                  "list": false,
                  "name": "code",
                  "show": true,
                  "type": "code",
                  "value": "# -*- coding: utf-8 -*-\nfrom axiestudio.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom axiestudio.base.io.chat import ChatComponent\nfrom axiestudio.inputs import BoolInput\nfrom axiestudio.io import DropdownInput, FileInput, MessageTextInput, MultilineInput, Output\nfrom axiestudio.memory import store_message\nfrom axiestudio.schema.message import Message\nfrom axiestudio.utils.MinioUtils import MinioUtils\n\nclass UniChatInput(ChatComponent):\n    display_name = \"对话输入\"\n    description = \"从调试窗口获得对话内容\"\n    icon = \"ChatInput\"\n    name = \"UniChatInput\"\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"文本\",\n            value=\"\",\n            info=\"要输入的消息。\",\n        ),\n        BoolInput(\n            name=\"store_message\",\n            display_name=\"存储消息\",\n            info=\"将消息存储到历史记录。\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"发送者类型\",\n            options=[\"Machine\", \"User\"],\n            value=\"User\",\n            info=\"发送者的类型。\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"发送者名称\",\n            info=\"发送者的名称。\",\n            value=\"User\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\", display_name=\"会话ID\", info=\"会话ID\", advanced=False\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"文件\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"与消息一同发送的文件。\",\n            advanced=True,\n            is_list=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"消息\", name=\"message\", method=\"message_response\"),\n    ]\n    def __init__(self, **kwargs):\n        # 调用父类的初始化方法\n        super().__init__(**kwargs)\n        self.icon= MinioUtils().get_full_path('zy-icons', 'UniChatInputComponent.png')\n    def message_response(self) -> Message:\n        message = Message(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n        )\n\n        if self.session_id and isinstance(message, Message) and isinstance(message.text, str):\n            store_message(\n                message,\n                flow_id=self.graph.flow_id,\n            )\n            self.message.value = message\n\n        self.status = message\n        return message\n",
                  "dynamic": true,
                  "advanced": true,
                  "password": false,
                  "required": true,
                  "fileTypes": [],
                  "file_path": "",
                  "multiline": true,
                  "title_case": false,
                  "placeholder": "",
                  "load_from_db": false
                },
                "_type": "Component",
                "files": {
                  "info": "与消息一同发送的文件。",
                  "list": true,
                  "name": "files",
                  "show": true,
                  "type": "file",
                  "value": "",
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "fileTypes": [
                    "txt",
                    "md",
                    "mdx",
                    "csv",
                    "json",
                    "yaml",
                    "yml",
                    "xml",
                    "html",
                    "htm",
                    "pdf",
                    "docx",
                    "py",
                    "sh",
                    "sql",
                    "js",
                    "ts",
                    "tsx",
                    "jpg",
                    "jpeg",
                    "png",
                    "bmp",
                    "image"
                  ],
                  "file_path": "",
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "文件",
                  "trace_as_metadata": true
                },
                "sender": {
                  "info": "发送者的类型。",
                  "name": "sender",
                  "show": true,
                  "type": "str",
                  "value": "User",
                  "dynamic": false,
                  "options": [
                    "Machine",
                    "User"
                  ],
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "发送者类型",
                  "trace_as_metadata": true
                },
                "session_id": {
                  "info": "会话ID",
                  "list": false,
                  "name": "session_id",
                  "show": true,
                  "type": "str",
                  "value": "",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "会话ID",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "input_value": {
                  "info": "要输入的消息。",
                  "list": false,
                  "name": "input_value",
                  "show": true,
                  "type": "str",
                  "value": "请帮我审核一下报销单:http://gis.unicloud.com:8086/test/danju.xlsx",
                  "dynamic": false,
                  "advanced": false,
                  "required": false,
                  "multiline": true,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "文本",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "sender_name": {
                  "info": "发送者的名称。",
                  "list": false,
                  "name": "sender_name",
                  "show": true,
                  "type": "str",
                  "value": "User",
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "input_types": [
                    "Message"
                  ],
                  "placeholder": "",
                  "display_name": "发送者名称",
                  "load_from_db": false,
                  "trace_as_input": true,
                  "trace_as_metadata": true
                },
                "store_message": {
                  "info": "将消息存储到历史记录。",
                  "list": false,
                  "name": "store_message",
                  "show": true,
                  "type": "bool",
                  "value": true,
                  "dynamic": false,
                  "advanced": true,
                  "required": false,
                  "title_case": false,
                  "placeholder": "",
                  "display_name": "存储消息",
                  "trace_as_metadata": true
                }
              },
              "description": "从调试窗口获得对话内容",
              "field_order": [
                "input_value",
                "store_message",
                "sender",
                "sender_name",
                "session_id",
                "files"
              ],
              "base_classes": [
                "Message"
              ],
              "display_name": "对话输入",
              "output_types": [],
              "custom_fields": {},
              "documentation": "",
              "conditional_paths": []
            },
            "type": "UniChatInput"
          },
          "type": "genericNode",
          "width": 384,
          "height": 403,
          "dragging": false,
          "position": {
            "x": -2011.5235258825771,
            "y": 583.1414648266773
          },
          "selected": true,
          "positionAbsolute": {
            "x": -2011.5235258825771,
            "y": 583.1414648266773
          }
        }
      ],
      "viewport": {
        "x": 982.8472970387796,
        "y": -210.16015321425948,
        "zoom": 0.4364091623803481
      }
    },
    "date_created": "2024-10-12T07:18:38.413Z",
    "date_updated": "2024-10-12T07:18:38.684Z",
    "status": "Public",
    "sort": null,
    "user_updated": "64bd3aa6-538a-4107-8754-c4a63e128385",
    "user_created": {
      "username": "huangxinghui",
      "first_name": "xinghui",
      "last_name": "huang",
      "id": "64bd3aa6-538a-4107-8754-c4a63e128385"
    },
    "tags": []
  },
  "conversion": {
    "converted_at": "2025-08-19T18:09:07.098Z",
    "converted_from": "langflow",
    "converted_to": "axiestudio",
    "conversions_made": 96,
    "converter_version": "1.0.0"
  }
}